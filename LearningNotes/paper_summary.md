
### æ ¸å¿ƒè¦ç´ åˆ†æ

*   **æ ¹æœ¬é—®é¢˜**
    ä¼ ç»Ÿä¸Šï¼Œä»æ•°æ®ä¸­è¯†åˆ«â€œæ··åˆç³»ç»Ÿâ€ï¼ˆå³ä¼šåœ¨ä¸åŒå·¥ä½œæ¨¡å¼é—´åˆ‡æ¢çš„ç³»ç»Ÿï¼‰ä¾èµ–äºæ£€æµ‹å…¶ä¿¡å·çš„â€œå¯¼æ•°çªå˜â€ã€‚è¿™ç§æ–¹æ³•ä¸ä»…å¯¹å™ªå£°æ•æ„Ÿï¼Œæ›´å…³é”®çš„æ˜¯éœ€è¦äººä¸ºè®¾å®šä¸€ä¸ªéš¾ä»¥æŠŠæ¡çš„â€œçªå˜é˜ˆå€¼â€â€”â€”é˜ˆå€¼å¤ªé«˜ä¼šæ¼æ‰çœŸå®çš„æ¨¡å¼åˆ‡æ¢ï¼Œå¤ªä½åˆ™ä¼šå¼•å…¥å¤§é‡è™šå‡çš„åˆ‡æ¢ç‚¹ï¼Œå°¤å…¶å¯¹äºå¤æ‚çš„éçº¿æ€§ç³»ç»Ÿï¼Œæ­¤çŸ›ç›¾å‡ ä¹æ— è§£ã€‚

*   **åˆ‡å…¥è§†è§’**
    æœ¬æ–‡æå‡ºäº†ä¸€ä¸ªæ ¹æœ¬æ€§çš„è§†è§’è½¬å˜ï¼šæ¨¡å¼åˆ‡æ¢çš„æœ¬è´¨ç‰¹å¾å¹¶éä¿¡å·çš„â€œå¯¼æ•°å‰§å˜â€ï¼Œè€Œæ˜¯ç³»ç»ŸèƒŒåâ€œåŠ¨æ€è§„å¾‹ï¼ˆdynamic modelï¼‰çš„ä¸å†é€‚ç”¨â€ã€‚å³ï¼Œåªè¦ç³»ç»Ÿéµå¾ªåŒä¸€å¥—ç‰©ç†æˆ–æ§åˆ¶æ³•åˆ™ï¼Œæ— è®ºå…¶ä¿¡å·å¦‚ä½•å˜åŒ–ï¼Œéƒ½åº”è¯¥èƒ½è¢«åŒä¸€ä¸ªæ•°å­¦æ¨¡å‹å®Œç¾æ‹Ÿåˆï¼›åä¹‹ï¼Œå½“è¿™ä¸ªæ¨¡å‹å¼€å§‹å¤±æ•ˆæ—¶ï¼Œå°±æ„å‘³ç€ç³»ç»Ÿåˆ‡æ¢åˆ°äº†ä¸€ä¸ªæ–°çš„å†…åœ¨æ¨¡å¼ã€‚

*   **å…³é”®æ–¹æ³•**
    ä½œè€…å°†ä¸Šè¿°è§†è§’è½åœ°ä¸ºä¸€ç§ç»Ÿä¸€ã€æ— é˜ˆå€¼çš„æ ¸å¿ƒæœºåˆ¶ï¼š**å°†éçº¿æ€§è‡ªå›å½’æ¨¡å‹ï¼ˆNARXï¼‰çš„æ‹Ÿåˆèƒ½åŠ›ä½œä¸ºâ€œè¯•é‡‘çŸ³â€**ã€‚å…·ä½“è€Œè¨€ï¼Œé€šè¿‡ä¸€ä¸ªæ»‘åŠ¨çª—å£æŒç»­å°è¯•ç”¨å•ä¸€ NARX æ¨¡å‹æ¥æ‹Ÿåˆå±€éƒ¨æ•°æ®æ®µï¼š
    1.  **åˆ†å‰² (Segmentation)ï¼š** å¦‚æœä¸€æ®µæ•°æ®èƒ½è¢«ä¸€ä¸ª NARX æ¨¡å‹å¾ˆå¥½åœ°æ‹Ÿåˆï¼Œåˆ™å®ƒå±äºåŒä¸€ä¸ªæ¨¡å¼ï¼›å½“æ‹Ÿåˆè¯¯å·®é¦–æ¬¡è¶…è¿‡ä¸€ä¸ªæå°çš„ã€æœºå™¨çº§çš„å®¹å¿åº¦æ—¶ï¼Œå³æ ‡å¿—ç€ä¸€ä¸ªæ¨¡å¼åˆ‡æ¢ç‚¹ã€‚
    2.  **èšç±» (Clustering)ï¼š** æ‰€æœ‰èƒ½è¢«*åŒä¸€ä¸ª* NARX æ¨¡å‹å‚æ•°æ‹Ÿåˆçš„æ•°æ®æ®µï¼Œéƒ½è¢«å½’ä¸ºåŒä¸€ç±»ï¼Œå³å¯¹åº”ç³»ç»Ÿçš„åŒä¸€ç§å·¥ä½œæ¨¡å¼ã€‚

*   **æ ¸å¿ƒå‘ç°**
    é€šè¿‡è¿™ç§"ä»¥æ¨¡å‹æ‹Ÿåˆåº¦é‡å†…åœ¨è§„å¾‹"çš„æ–¹æ³•ï¼Œå¯ä»¥åœ¨æ— éœ€ä»»ä½•äººå·¥é˜ˆå€¼çš„æƒ…å†µä¸‹ï¼Œç²¾ç¡®ã€é²æ£’åœ°ä»è§‚æµ‹æ•°æ®ä¸­åæ¨å‡ºé«˜é˜¶ã€éçº¿æ€§æ··åˆç³»ç»Ÿçš„å®Œæ•´ç»“æ„ï¼ˆåŒ…æ‹¬æ¯ç§æ¨¡å¼ä¸‹çš„åŠ¨æ€æ–¹ç¨‹ã€æ¨¡å¼åˆ‡æ¢çš„è¾¹ç•Œæ¡ä»¶ä»¥åŠåˆ‡æ¢æ—¶çš„çŠ¶æ€é‡ç½®è§„åˆ™ï¼‰ï¼Œå…¶ç²¾åº¦å’Œé€‚ç”¨èŒƒå›´å‡æ˜¾è‘—è¶…è¶Šäº†ä¾èµ–å¯¼æ•°çªå˜çš„ä¼ ç»Ÿæ–¹æ³•ã€‚

---

## æŠ€æœ¯å®ç°è¯¦è§£

### 1. NARX æ¨¡å‹çš„æ•°å­¦å½¢å¼

NARX (Nonlinear AutoRegressive with eXogenous inputs) æ¨¡å‹æ˜¯æœ¬æ–¹æ³•çš„æ ¸å¿ƒå·¥å…·ã€‚å¯¹äºç¬¬ i ä¸ªçŠ¶æ€å˜é‡ï¼Œå…¶ NARX æ¨¡å‹å½¢å¼ä¸ºï¼š

```
x_i[t] = Î£(a_j Â· x_i[t-j]) + Î£(b_k Â· u_k[t]) + Î£(c_l Â· Ï†_l(x, u)) + bias
         j=1 to order      k=1 to input_num    l=1 to nonlinear_terms
```

å…¶ä¸­ï¼š
- `x_i[t]` æ˜¯ç¬¬ i ä¸ªçŠ¶æ€å˜é‡åœ¨æ—¶åˆ» t çš„å€¼
- `a_j` æ˜¯è‡ªå›å½’ç³»æ•°ï¼Œæ•æ‰å†å²çŠ¶æ€çš„å½±å“
- `u_k[t]` æ˜¯å¤–éƒ¨è¾“å…¥ä¿¡å·
- `Ï†_l(x, u)` æ˜¯å¯é€‰çš„éçº¿æ€§é¡¹ï¼ˆå¦‚ xâ‚Â·xâ‚‚, sin(xâ‚) ç­‰ï¼‰
- `order` æ˜¯æ¨¡å‹é˜¶æ•°ï¼Œå†³å®šäº†å†å²ä¾èµ–çš„æ—¶é—´æ·±åº¦

**ä»£ç å®ç°** (src/DEConfig.py:147-159)ï¼š
```python
def append_data(self, matrix_list, b_list, data: np.array, input_data):
    """æ„é€  NARX æ¨¡å‹çš„æœ€å°äºŒä¹˜å›å½’çŸ©é˜µ"""
    data = np.array(data)
    input_data = np.array(input_data)
    for i in range(len(data[0]) - self.order):
        # æå–æ»åé¡¹ x[t-1], x[t-2], ..., x[t-order]
        if i == 0:
            this_line = data[:, (self.order - 1)::-1]
            this_line_input = input_data[:, self.order::-1]
        else:
            this_line = data[:, (self.order + i - 1):(i - 1):-1]
            this_line_input = input_data[:, (self.order + i):(i - 1):-1]
        for idx in range(len(this_line)):
            # æ„é€ ç‰¹å¾å‘é‡ [x[t-1], x[t-2], ..., u[t], bias, nonlinear_terms]
            matrix_list[idx].append(self.get_items(this_line, this_line_input, idx))
            b_list[idx].append(data[idx][i + self.order])  # ç›®æ ‡å€¼ x[t]
```

#### 1.1 éçº¿æ€§é¡¹çš„æ·»åŠ è¿‡ç¨‹

å®Œæ•´çš„éçº¿æ€§é¡¹å·¥ä½œæµç¨‹

  æ­¥éª¤1ï¼šåœ¨åˆå§‹åŒ–æ—¶è§£æéçº¿æ€§è¡¨è¾¾å¼
  ```python
class FeatureExtractor:
    def __init__(self, var_num: int, input_num: int, order: int, dt: float,
               need_bias: bool = False, minus: bool = False, other_items: str = ''):
      self.var_num = var_num
      self.order = order
      self.dt = dt
      self.input_num = input_num
      self.minus = minus
      self.need_bias = need_bias
      # â­ å…³é”®ï¼šå°†å­—ç¬¦ä¸²è¡¨è¾¾å¼è½¬æ¢ä¸ºå¯è°ƒç”¨çš„å‡½æ•°
      self.fun_list, self.fun_order = FeatureExtractor.analyticalExpression(
          other_items,  # â† ä¾‹å¦‚: "x[1]*x[2]; x[1]**2; sin(x[1])"
          var_num,
          order
      )
  ```
  æ­¥éª¤2ï¼šanalyticalExpression å°†å­—ç¬¦ä¸²è½¬æ¢ä¸º lambda å‡½æ•°
  ```python
  @staticmethod
  def analyticalExpression(expr_list: str, var_num, order):
      """å°†å­—ç¬¦ä¸²è¡¨è¾¾å¼è§£æä¸ºå¯æ‰§è¡Œçš„ lambda å‡½æ•°"""
      res = [[] for _ in range(var_num)]
      res_order = [[] for _ in range(var_num)]

      expr_list = expr_list.split(';')  # åˆ†å‰²å¤šä¸ªè¡¨è¾¾å¼

      for idx in range(var_num):
          expr = FeatureExtractor.extractValidExpression(expr_list, idx)
          expr = FeatureExtractor.unfoldDigit(expr, order)
          expr = FeatureExtractor.unfoldItem(expr, idx, var_num)

          for s in expr:
              # â­ æ ¸å¿ƒï¼šå°†å­—ç¬¦ä¸²è½¬æ¢ä¸º lambda å‡½æ•°
              res[idx].append(eval('lambda x: ' + s))
              # ä¾‹å¦‚ï¼š"x[0][1]*x[1][1]" â†’ lambda x: x[0][1]*x[1][1]
              res_order[idx].append(FeatureExtractor.findMaxorder(s) + 1)

      return res, res_order
  ```
  æ­¥éª¤3ï¼šget_items è°ƒç”¨è¿™äº› lambda å‡½æ•°
  ```python
  def get_items(self, data, input_data, idx, max_order=None):
      res = []

      # ... æ·»åŠ çº¿æ€§æ»åé¡¹ ...

      # â­ è¿™é‡Œæ‰§è¡Œéçº¿æ€§å‡½æ•°ï¼
      for (fun, order) in zip(self.fun_list[idx], self.fun_order[idx]):
          if order > max_order:
              res.append(0.)
          else:
              res.append(fun(data))  # è°ƒç”¨ lambda å‡½æ•°
              # ä¾‹å¦‚ï¼šfun = lambda x: x[0][1] * x[1][1]
              #      data = [[...], [...], ...]
              #      ç»“æœï¼šdata[0][1] * data[1][1]

      # ... æ·»åŠ è¾“å…¥é¡¹å’Œåç½®é¡¹ ...

      return res
  ```
  å…·ä½“ç¤ºä¾‹è¯´æ˜
  
  å‡è®¾æˆ‘ä»¬è¦ä¸º Duffing æŒ¯å­æ·»åŠ éçº¿æ€§é¡¹ï¼š
```python
  # é…ç½®æ–‡ä»¶ä¸­è®¾ç½®
  config = {
      "order": 3,
      "other_items": "x[1]**3; x[1]*x[2]"  # â† å®šä¹‰éçº¿æ€§é¡¹
  }

  # åˆå§‹åŒ–æ—¶
  get_feature = FeatureExtractor(
      var_num=2,      # ä¸¤ä¸ªçŠ¶æ€å˜é‡ x1, x2
      input_num=1,
      order=3,
      dt=0.01,
      other_items="x[1]**3; x[1]*x[2]"
  )

  # æ­¤æ—¶ self.fun_list åŒ…å«ï¼š
  # fun_list[0] = [lambda x: x[0][0]**3, lambda x: x[0][0]*x[1][0]]
  # fun_list[1] = [lambda x: x[1][0]**3, lambda x: x[1][0]*x[2][0]]
  ```
  åœ¨æ‹Ÿåˆæ—¶ï¼Œå¯¹äºç¬¬ä¸€ä¸ªå˜é‡ï¼ˆidx=0ï¼‰ï¼Œç‰¹å¾å‘é‡æ„æˆä¸ºï¼š
  ```python
  ç‰¹å¾å‘é‡ = [
      x1[t-1],           # çº¿æ€§æ»åé¡¹
      x1[t-2],
      x1[t-3],
      (x1[t-1])Â³,        # â† éçº¿æ€§é¡¹ 1: x[1]**3
      x1[t-1] * x2[t-1], # â† éçº¿æ€§é¡¹ 2: x[1]*x[2]
      u[t],              # è¾“å…¥é¡¹
      1                  # åç½®é¡¹
  ]
  ```
  æœ€ç»ˆçš„ NARX æ¨¡å‹å°±å˜æˆï¼š
  ```python
  x1[t] = a1Â·x1[t-1] + a2Â·x1[t-2] + a3Â·x1[t-3]
          + a4Â·(x1[t-1])Â³           # â† éçº¿æ€§é¡¹
          + a5Â·x1[t-1]Â·x2[t-1]      # â† äº¤å‰éçº¿æ€§é¡¹
          + b1Â·u[t]
          + bias
  ```
  â˜… Insight â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  1. éçº¿æ€§é¡¹çš„å¯æ‰©å±•æ€§ï¼šé€šè¿‡å­—ç¬¦ä¸²è¡¨è¾¾å¼ + eval() çš„è®¾è®¡ï¼Œç”¨æˆ·å¯ä»¥çµæ´»æ·»åŠ ä»»æ„æ•°å­¦è¡¨è¾¾å¼ï¼ˆå¦‚ä¸‰è§’å‡½æ•°ã€æŒ‡æ•°ã€å¤šé¡¹å¼ç­‰ï¼‰ï¼Œè€Œä¸éœ€è¦ä¿®æ”¹æ ¸å¿ƒä»£ç ã€‚
  2. "æƒ°æ€§æ±‚å€¼"è®¾è®¡ï¼šfun_list å­˜å‚¨çš„æ˜¯ lambda å‡½æ•°è€Œä¸æ˜¯å…·ä½“å€¼ï¼Œåªæœ‰åœ¨è°ƒç”¨ get_items() æ—¶æ‰å®é™…è®¡ç®—ï¼Œé¿å…äº†ä¸å¿…è¦çš„å†…å­˜å¼€é”€ã€‚
  3. è¿™ç§è®¾è®¡ä½“ç°äº†è®ºæ–‡çš„æ ¸å¿ƒæ€æƒ³ï¼šNARX æ¨¡å‹ä¸ä»…ä»…æ˜¯çº¿æ€§è‡ªå›å½’ï¼Œé€šè¿‡æ·»åŠ éçº¿æ€§é¡¹ï¼Œå®ƒå¯ä»¥é€¼è¿‘ä»»æ„å¤æ‚çš„éçº¿æ€§åŠ¨åŠ›å­¦ç³»ç»Ÿï¼ˆç±»ä¼¼äºç¥ç»ç½‘ç»œçš„é€šç”¨é€¼è¿‘å®šç†ï¼‰ã€‚
  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  ä»£ç æµç¨‹æ€»ç»“
  ```markdown

  ç”¨æˆ·é…ç½®: other_items = "x[1]**3; sin(x[1])"
      â†“
  [åˆå§‹åŒ–é˜¶æ®µ]
  analyticalExpression() è§£æå­—ç¬¦ä¸²
      â†“
  ç”Ÿæˆ fun_list = [lambda x: x[0][0]**3, lambda x: sin(x[0][0])]
      â†“
  [æ‹Ÿåˆé˜¶æ®µ]
  append_data() æ„é€ å›å½’çŸ©é˜µ
      â†“
      â†“
  get_items() ä¾æ¬¡æ·»åŠ ï¼š
    - çº¿æ€§æ»åé¡¹
    - éçº¿æ€§é¡¹ â† è°ƒç”¨ fun(data)
    - è¾“å…¥é¡¹
    - åç½®é¡¹
      â†“
  è¿”å›å®Œæ•´ç‰¹å¾å‘é‡ç”¨äºæœ€å°äºŒä¹˜æ‹Ÿåˆ
  ```
**æœ€å°äºŒä¹˜æ‹Ÿåˆ** (src/DEConfig.py:124-139)ï¼š
```python
def work_normal(self, data, input_data, is_list: bool):
    """ä½¿ç”¨æœ€å°äºŒä¹˜æ³•æ‹Ÿåˆ NARX æ¨¡å‹"""
    res = []
    err = []
    var_num = len(data) if not is_list else len(data[0])
    matrix_list = [[] for _ in range(var_num)]
    b_list = [[] for _ in range(var_num)]

    # æ„é€ å›å½’çŸ©é˜µ A å’Œç›®æ ‡å‘é‡ b
    if is_list:
        for block, block_input in zip(data, input_data):
            self.append_data(matrix_list, b_list, block, block_input)
    else:
        self.append_data(matrix_list, b_list, data, input_data)

    # å¯¹æ¯ä¸ªå˜é‡æ±‚è§£ min ||Ax - b||Â²
    for a, b in zip(matrix_list, b_list):
        x = np.linalg.lstsq(a, b, rcond=None)[0]  # æœ€å°äºŒä¹˜è§£
        res.append(x)
        err.append(max(np.abs((a @ x) - b)))  # æœ€å¤§æ‹Ÿåˆæ®‹å·®
    return res, err, [self.order for _ in range(self.var_num)]
```

### 2. æœºå™¨çº§å®¹å¿åº¦çš„è®¡ç®—

è¿™æ˜¯"æ— é˜ˆå€¼"æ–¹æ³•çš„å…³é”®â€”â€”ä¸æ˜¯å®Œå…¨æ²¡æœ‰é˜ˆå€¼ï¼Œè€Œæ˜¯ä½¿ç”¨ä¸€ä¸ª**ä¸æ•°æ®å°ºåº¦è‡ªé€‚åº”çš„æå°é˜ˆå€¼**ï¼Œé¿å…äººä¸ºè°ƒå‚ã€‚

**ä»£ç å®ç°** (src/DEConfig.py:77-78)ï¼š
```python
def get_eps(self, data):
    """è®¡ç®—æœºå™¨çº§å®¹å¿åº¦é˜ˆå€¼"""
    return 1e-6 * self.dt * np.max(data)
```

è¿™ä¸ªå…¬å¼çš„è®¾è®¡æ€æƒ³ï¼š
- `1e-6` æ˜¯ä¸€ä¸ªæ¥è¿‘æµ®ç‚¹è¿ç®—ç²¾åº¦çš„æå°å¸¸æ•°
- `dt` æ˜¯é‡‡æ ·æ—¶é—´é—´éš”ï¼Œå°†è¯¯å·®å½’ä¸€åŒ–åˆ°å•ä½æ—¶é—´
- `np.max(data)` ä½¿é˜ˆå€¼ä¸æ•°æ®é‡çº§æˆæ­£æ¯”ï¼Œé€‚åº”ä¸åŒå°ºåº¦çš„ç³»ç»Ÿ

**ä¸¾ä¾‹**ï¼šå¦‚æœæ•°æ®æœ€å¤§å€¼ä¸º 100ï¼Œé‡‡æ ·é—´éš” dt=0.01ï¼Œåˆ™ `eps = 1e-6 * 0.01 * 100 = 1e-6`ï¼Œè¿™æ˜¯ä¸€ä¸ªæå°çš„æ‹Ÿåˆè¯¯å·®è¦æ±‚ã€‚

### 3. æ»‘åŠ¨çª—å£åˆ†å‰²ç®—æ³•

åˆ†å‰²ç®—æ³•é€šè¿‡æ»‘åŠ¨çª—å£æ£€æµ‹æ¨¡å¼åˆ‡æ¢ç‚¹ï¼Œæ ¸å¿ƒæ€æƒ³æ˜¯ï¼š**å½“å•ä¸€ NARX æ¨¡å‹æ— æ³•ç»§ç»­æ‹Ÿåˆæ–°æ•°æ®æ—¶ï¼Œæ ‡è®°ä¸ºåˆ‡æ¢ç‚¹**ã€‚

**ç®—æ³•æµç¨‹** (src/ChangePoints.py:16-49)ï¼š
```python
def find_change_point(data: np.array, input_data: np.array, get_feature, w: int = 10, merge_th=None):
    """
    å‚æ•°ï¼š
        data: çŠ¶æ€å˜é‡æ—¶é—´åºåˆ— (Nå˜é‡ Ã— Mæ—¶é—´ç‚¹)
        input_data: è¾“å…¥ä¿¡å·æ—¶é—´åºåˆ—
        get_feature: NARX æ‹Ÿåˆå‡½æ•°ï¼ˆFeatureExtractor å®ä¾‹ï¼‰
        w: æ»‘åŠ¨çª—å£å¤§å°
        merge_th: åˆå¹¶ç›¸é‚»åˆ‡æ¢ç‚¹çš„é˜ˆå€¼
    """
    change_points = []
    pos = 0
    last = None
    tail_len = 0
    if merge_th is None:
        merge_th = w

    # è®¡ç®—æœºå™¨çº§å®¹å¿åº¦
    eps = get_feature.get_eps(data)

    # æ»‘åŠ¨çª—å£éå†æ—¶é—´åºåˆ—
    while pos + w < data.shape[1]:
        # å¯¹å½“å‰çª—å£æ‹Ÿåˆ NARX æ¨¡å‹
        feature, now_err, fit_order = get_feature(data[:, pos:(pos + w)],
                                                   input_data[:, pos:(pos + w)])

        if last is not None:
            # æ ¸å¿ƒåˆ¤æ–­ï¼šå¦‚æœæ‹Ÿåˆè¯¯å·®è¶…è¿‡å®¹å¿åº¦ï¼Œæ ‡è®°åˆ‡æ¢ç‚¹
            if (max(now_err) > eps) and tail_len == 0:
                change_points.append(pos + w - 1)
                tail_len = w  # é¿å…åœ¨åŒä¸€åŒºåŸŸé‡å¤æ£€æµ‹
            tail_len = max(tail_len - 1, 0)

        last = fit_order
        pos += 1  # çª—å£æ¯æ¬¡æ»‘åŠ¨ 1 ä¸ªæ—¶é—´æ­¥

    # åˆå¹¶è¿‡äºæ¥è¿‘çš„åˆ‡æ¢ç‚¹
    res = mergeChangePoints(change_points, merge_th)
    res.append(data.shape[1])
    res.insert(0, 0)
    return res
```

#### 3.1 æ»‘åŠ¨çª—å£å·¥ä½œæœºåˆ¶è¯¦è§£

**æ¯ä¸ªçª—å£ç‹¬ç«‹æ‹Ÿåˆ**ï¼š
```python
feature, now_err, fit_order = get_feature(data[:, pos:(pos + w)], input_data[:, pos:(pos + w)])
```

è¿™ä¸€è¡Œä»£ç åœ¨æ¯æ¬¡å¾ªç¯ä¸­æ‰§è¡Œä»¥ä¸‹æ“ä½œï¼š

1. **æå–çª—å£æ•°æ®**ï¼š`data[:, pos:(pos + w)]` æå–é•¿åº¦ä¸º `w` çš„æ—¶é—´çª—å£
2. **æ„é€ å›å½’çŸ©é˜µ**ï¼šé€šè¿‡ `append_data()` æ„é€  NARX ç‰¹å¾çŸ©é˜µ `A` å’Œç›®æ ‡å‘é‡ `b`
3. **æœ€å°äºŒä¹˜æ‹Ÿåˆ**ï¼šæ±‚è§£ `min ||Ax - b||Â²` å¾—åˆ°æ¨¡å‹å‚æ•° `x`
4. **è®¡ç®—æ‹Ÿåˆè¯¯å·®**ï¼š`now_err = max(|Ax - b|)`ï¼Œå³é¢„æµ‹å€¼ä¸çœŸå®å€¼çš„æœ€å¤§æ®‹å·®

**æ»‘åŠ¨è¿‡ç¨‹ç¤ºä¾‹**ï¼ˆå‡è®¾ `w=10`ï¼Œæ€»æ—¶é—´ç‚¹ `M=100`ï¼‰ï¼š
```
è¿­ä»£ 1:  pos=0   â†’ æ‹Ÿåˆ data[0:10]   â†’ errâ‚
è¿­ä»£ 2:  pos=1   â†’ æ‹Ÿåˆ data[1:11]   â†’ errâ‚‚
è¿­ä»£ 3:  pos=2   â†’ æ‹Ÿåˆ data[2:12]   â†’ errâ‚ƒ
...
è¿­ä»£ 90: pos=89  â†’ æ‹Ÿåˆ data[89:99]  â†’ errâ‚‰â‚€
è¿­ä»£ 91: pos=90  â†’ æ‹Ÿåˆ data[90:100] â†’ errâ‚‰â‚  (æœ€åä¸€ä¸ªçª—å£)

æ€»æ‹Ÿåˆæ¬¡æ•°: M - w = 90 æ¬¡
```

#### 3.2 ä¸ºä»€ä¹ˆå‚æ•°é‡æ‹Ÿåˆä¸ä¼šæ©ç›–å˜ç‚¹ï¼Ÿ

**å…³é”®æ´å¯Ÿ**ï¼šè™½ç„¶æ¯ä¸ªçª—å£éƒ½é‡æ–°ä¼˜åŒ–å‚æ•°ï¼Œä½†å½“çª—å£è·¨è¶Šå˜ç‚¹æ—¶ï¼Œå•ä¸€ NARX æ¨¡å‹é¢ä¸´"ä¸å¯èƒ½å®Œæˆçš„ä»»åŠ¡"ã€‚

**åœºæ™¯ç¤ºä¾‹ï¼šå¼¹è·³çƒç³»ç»Ÿ**
```
æ—¶é—´ç‚¹:  0  1  2  3  4  5  6  7  8  9  10 11 12 13 14 15
æ¨¡æ€:    [------- æ¨¡æ€1: è‡ªç”±è½ä½“ -------][å˜ç‚¹][--- æ¨¡æ€2: é™æ­¢ ---]
é€Ÿåº¦:    -1 -2 -3 -4 -5 -6 -7 -8 -9 -10   0  0  0  0  0  0
åŠ¨åŠ›å­¦:  v[t+1] = v[t] - gÂ·dt              v[t+1] = 0
```

**çª—å£1 [0:10]ï¼ˆçº¯æ¨¡æ€1ï¼‰**ï¼š
```
æ•°æ®: v = [-1, -2, -3, -4, -5, -6, -7, -8, -9, -10]
æ‹Ÿåˆ: v[t+1] = aÂ·v[t] + b  â†’  aâ‰ˆ1.0, bâ‰ˆ-1.0
æ®‹å·®: |Ax - b| â‰ˆ 1e-10  (å®Œç¾æ‹Ÿåˆ)
ç»“è®º: err < eps âœ“  æ— å˜ç‚¹
```

**çª—å£2 [5:15]ï¼ˆè·¨è¶Šå˜ç‚¹ï¼ï¼‰**ï¼š
```
æ•°æ®: v = [-5, -6, -7, -8, -9, -10, 0, 0, 0, 0]
                                    â†‘ å˜ç‚¹åœ¨è¿™é‡Œ
å°è¯•æ‹Ÿåˆå•ä¸€æ¨¡å‹ v[t+1] = aÂ·v[t] + b:
  - å‰åŠéƒ¨åˆ†éœ€è¦: aâ‰ˆ1, bâ‰ˆ-1  (ä¸‹è½è§„å¾‹)
  - ååŠéƒ¨åˆ†éœ€è¦: aâ‰ˆ0, bâ‰ˆ0   (é™æ­¢è§„å¾‹)
  â†’ æœ€å°äºŒä¹˜æ‰¾åˆ°æŠ˜ä¸­è§£: aâ‰ˆ0.5, bâ‰ˆ-0.5
  â†’ å‰åŠéƒ¨åˆ†æ®‹å·®: |-6 - (0.5Ã—(-5) - 0.5)| = |-6 - (-3)| = 3
  â†’ ååŠéƒ¨åˆ†æ®‹å·®: |0 - (0.5Ã—0 - 0.5)| = 0.5
æ®‹å·®: max(|Ax - b|) â‰ˆ 3.0  (æ˜¾è‘—å¢å¤§ï¼)
ç»“è®º: err >> eps âœ—  æ£€æµ‹åˆ°å˜ç‚¹
```

**çª—å£3 [10:20]ï¼ˆçº¯æ¨¡æ€2ï¼‰**ï¼š
```
æ•°æ®: v = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
æ‹Ÿåˆ: v[t+1] = 0  (å¸¸æ•°æ¨¡å‹)
æ®‹å·®: â‰ˆ 1e-10  (å®Œç¾æ‹Ÿåˆ)
ç»“è®º: err < eps âœ“  æ— å˜ç‚¹
```

**æ•°å­¦è§£é‡Š**ï¼š
å½“çª—å£åŒ…å« `nâ‚` ä¸ªæ¨¡æ€1æ•°æ®å’Œ `nâ‚‚` ä¸ªæ¨¡æ€2æ•°æ®æ—¶ï¼Œä¼˜åŒ–é—®é¢˜ä¸ºï¼š

$$
\min_{\theta} \left[ \sum_{i=1}^{n_1} (y_i^{(1)} - f_\theta(x_i))^2 + \sum_{j=1}^{n_2} (y_j^{(2)} - f_\theta(x_j))^2 \right]
$$

- å•ä¸€å‚æ•° $\theta$ å¿…é¡»åŒæ—¶æ‹Ÿåˆä¸¤ä¸ªä¸åŒçš„åŠ¨åŠ›å­¦ç³»ç»Ÿ
- è¿™å¯¼è‡´ä¸¤ä¸ªç›®æ ‡ç›¸äº’å†²çªï¼Œæœ€å°äºŒä¹˜è§£æ˜¯ä¸€ä¸ªæŠ˜ä¸­å€¼
- æŠ˜ä¸­è§£åœ¨ä¸¤ä¸ªæ¨¡æ€ä¸Šçš„æ‹Ÿåˆè´¨é‡éƒ½ä¼šä¸‹é™ï¼Œæ®‹å·®æ˜¾è‘—å¢å¤§

**å…³é”®è®¾è®¡**ï¼š
- **tail_len æœºåˆ¶**ï¼šæ£€æµ‹åˆ°åˆ‡æ¢ç‚¹åï¼Œè·³è¿‡åç»­ `w` ä¸ªä½ç½®ï¼Œé¿å…åœ¨åŒä¸€åˆ‡æ¢è¾¹ç•Œé‡å¤æ ‡è®°
- **mergeChangePoints**ï¼šå¦‚æœä¸¤ä¸ªåˆ‡æ¢ç‚¹é—´éš”å°äº `merge_th`ï¼Œåªä¿ç•™ç¬¬ä¸€ä¸ªï¼Œæ¶ˆé™¤å™ªå£°å¯¼è‡´çš„è™šå‡æ£€æµ‹
- **è‡ªé€‚åº”é˜ˆå€¼ eps**ï¼š`1e-6 * dt * max(data)` ç¡®ä¿é˜ˆå€¼ä¸æ•°æ®å°ºåº¦æˆæ­£æ¯”ï¼Œçº¯æ¨¡æ€çª—å£çš„è¯¯å·®é€šå¸¸è¿œå°äº `eps`ï¼ˆçº¦ `1e-10`ï¼‰ï¼Œè€Œè·¨æ¨¡æ€çª—å£è¯¯å·®å¯è¾¾ `1e-3` ä»¥ä¸Š

**å¯è§†åŒ–ç†è§£**ï¼š
```
æ—¶é—´åºåˆ—: |====æ¨¡å¼A====|****|====æ¨¡å¼B====|****|====æ¨¡å¼C====|
çª—å£ä½ç½®:  [----w----]                              â† pos=0,  errâ‰ˆ1e-10
            [----w----]                             â† pos=1,  errâ‰ˆ1e-10
                [----w----]                         â† pos=5,  errâ‰ˆ1e-10
                    [----w----]                     â† pos=10, errâ‰ˆ1e-3 âœ— å˜ç‚¹!
                        [----w----]                 â† pos=15, errâ‰ˆ1e-10
                              [----w----]           â† pos=20, errâ‰ˆ1e-10
                                    [----w----]     â† pos=30, errâ‰ˆ1e-3 âœ— å˜ç‚¹!

æ£€æµ‹é€»è¾‘: max(now_err) > eps  â†’  æ ‡è®°å˜ç‚¹
```

#### 3.3 è®¡ç®—å¤æ‚åº¦ä¸æ•ˆç‡

- **æ€»æ—¶é—´ç‚¹æ•°**ï¼š`M`
- **çª—å£å¤§å°**ï¼š`w` (å…¸å‹å€¼ 10-20)
- **æ‹Ÿåˆæ¬¡æ•°**ï¼š`M - w` æ¬¡ï¼ˆçº¿æ€§å¤æ‚åº¦ï¼‰
- **æ¯æ¬¡æ‹Ÿåˆå¤æ‚åº¦**ï¼š`O(w Â· dÂ²)`ï¼Œå…¶ä¸­ `d` æ˜¯ç‰¹å¾ç»´åº¦ï¼ˆorder + éçº¿æ€§é¡¹æ•°é‡ï¼‰
- **æ€»å¤æ‚åº¦**ï¼š`O(M Â· w Â· dÂ²)` â€” å¯¹äºå®é™…è§„æ¨¡çš„æ•°æ®ï¼ˆM~1000, w~10, d~10ï¼‰ä»ç„¶é«˜æ•ˆ

### 4. åŠ¨æ€é˜ˆå€¼æ ¡å‡†

è™½ç„¶åˆ†å‰²é˜¶æ®µä½¿ç”¨äº†æœºå™¨çº§é˜ˆå€¼ï¼Œä½†åœ¨èšç±»é˜¶æ®µéœ€è¦ä¸€ä¸ªæ›´å®½æ¾çš„é˜ˆå€¼ï¼Œç”¨äºåˆ¤æ–­"ä¸¤ä¸ªæ•°æ®æ®µæ˜¯å¦å±äºåŒä¸€æ¨¡å¼"ã€‚è¿™ä¸ªé˜ˆå€¼é€šè¿‡**è®­ç»ƒæ•°æ®è‡ªåŠ¨æ ¡å‡†**ï¼Œé¿å…äº†äººå·¥è°ƒå‚çš„å›°æ‰°ã€‚

#### 4.1 ä¸ºä»€ä¹ˆéœ€è¦åŠ¨æ€é˜ˆå€¼æ ¡å‡†ï¼Ÿ

åœ¨å®Œæˆæ•°æ®åˆ†å‰²åï¼Œæ‰€æœ‰è½¨è¿¹çš„ç‰‡æ®µï¼ˆsegmentsï¼‰éƒ½è¢«ä¿å­˜åœ¨ `slice_data` åˆ—è¡¨ä¸­ã€‚è¿™äº›ç‰‡æ®µéœ€è¦è¢«è¿›ä¸€æ­¥èšç±»ä»¥è¯†åˆ«ä¸åŒçš„åŠ¨æ€æ¨¡å¼ã€‚å…³é”®é—®é¢˜æ˜¯ï¼š**å¦‚ä½•åˆ¤æ–­ä¸¤ä¸ªç‰‡æ®µæ˜¯å¦å±äºåŒä¸€æ¨¡å¼ï¼Ÿ**

ä¼ ç»Ÿæ–¹æ³•é€šè¿‡æ¯”è¾ƒå‚æ•°å‘é‡çš„æ¬§æ°è·ç¦»(DTW)æ¥åˆ¤æ–­ï¼Œä½†è¿™ç§æ–¹æ³•å­˜åœ¨è‡´å‘½ç¼ºé™·ï¼š
- **é˜ˆå€¼çš„äººå·¥è®¾å®š**ï¼šè·ç¦»é˜ˆå€¼éœ€è¦æ‰‹åŠ¨è°ƒæ•´ï¼Œç¼ºä¹ç‰©ç†æ„ä¹‰
- **å°ºåº¦æ•æ„Ÿæ€§**ï¼šä¸åŒç³»ç»Ÿçš„å‚æ•°é‡çº§å·®å¼‚å·¨å¤§ï¼Œå›ºå®šé˜ˆå€¼æ— æ³•é€‚åº”
- **å™ªå£°æ•æ„Ÿæ€§**ï¼šå‚æ•°æ‰°åŠ¨å¯èƒ½å¯¼è‡´è·ç¦»è¶…è¿‡é˜ˆå€¼ï¼Œè¯¯åˆ¤ä¸ºä¸åŒæ¨¡å¼

æœ¬æ–¹æ³•é‡‡ç”¨**æ•°æ®é©±åŠ¨çš„è‡ªé€‚åº”é˜ˆå€¼å­¦ä¹ **ï¼Œä»è®­ç»ƒæ•°æ®æœ¬èº«æ¨æ–­å‡ºåˆç†çš„é˜ˆå€¼èŒƒå›´ã€‚

#### 4.2 é˜ˆå€¼æ ¡å‡†çš„æ ¸å¿ƒæ€æƒ³

**åŸºæœ¬å‡è®¾**ï¼šåœ¨æ—¶é—´åºåˆ—ä¸­ï¼Œç›¸é‚»ç‰‡æ®µé€šå¸¸æ¥è‡ªä¸åŒæ¨¡å¼ï¼ˆå› ä¸ºå®ƒä»¬ç”±å˜åŒ–ç‚¹åˆ†å‰²ï¼‰ã€‚å› æ­¤ï¼Œ**ç›¸é‚»ç‰‡æ®µä¹‹é—´çš„æ‹Ÿåˆè¯¯å·®å¯ä»¥ä½œä¸º"æ¨¡å¼é—´æœ€å°å·®å¼‚"çš„ä¼°è®¡**ã€‚

**æ ¡å‡†ç­–ç•¥**ï¼š
1. éå†æ‰€æœ‰ç›¸é‚»ç‰‡æ®µå¯¹ `(slice[i], slice[i+1])`
2. å°è¯•ç”¨å•ä¸€ NARX æ¨¡å‹åŒæ—¶æ‹Ÿåˆè¿™ä¸¤ä¸ªç‰‡æ®µ
3. è®°å½•æ‹Ÿåˆè¯¯å·® `err` å’Œå‚æ•°å·®å¼‚ `dis`
4. å°†é˜ˆå€¼è®¾ä¸ºæ‰€æœ‰è¯¯å·®çš„ **10%**ï¼ˆ`ToleranceRatio = 0.1`ï¼‰

è¿™æ ·è®¾å®šçš„é˜ˆå€¼æ—¢èƒ½åŒºåˆ†ä¸åŒæ¨¡å¼ï¼ˆè¯¯å·®è¿œå¤§äºé˜ˆå€¼ï¼‰ï¼Œåˆèƒ½å®¹å¿åŒä¸€æ¨¡å¼å†…çš„å°å¹…æ³¢åŠ¨ï¼ˆè¯¯å·®è¿œå°äºé˜ˆå€¼ï¼‰ã€‚

#### 4.3 ä»£ç å®ç°æµç¨‹

**ä¸»æµç¨‹**ï¼ˆmain.py:40-46ï¼‰ï¼š
```python
# ç¬¬1æ­¥ï¼šåˆ‡åˆ†æ‰€æœ‰è½¨è¿¹ï¼Œå¾—åˆ°ç‰‡æ®µåˆ—è¡¨
slice_data = []
for data, input_val in zip(data_list, input_data):
    change_points = find_change_point(data, input_val, get_feature, w=config['window_size'])
    slice_curve(slice_data, data, input_val, change_points, get_feature)
    # â†‘ slice_curve å°†æ¯æ¡è½¨è¿¹æŒ‰å˜åŒ–ç‚¹åˆ‡åˆ†ï¼Œå¹¶æŠŠæ‰€æœ‰ç‰‡æ®µç´¯ç§¯åˆ° slice_data ä¸­

# ç¬¬2æ­¥ï¼šè®¾ç½®èšç±»æ–¹æ³•
Slice.Method = config['clustering_method']  # 'fit' æˆ– 'dis'

# ç¬¬3æ­¥ï¼šåŠ¨æ€æ ¡å‡†é˜ˆå€¼ â† æ ¸å¿ƒæ­¥éª¤
Slice.fit_threshold(slice_data)

# ç¬¬4æ­¥ï¼šä½¿ç”¨æ ¡å‡†çš„é˜ˆå€¼è¿›è¡Œèšç±»
clustering(slice_data, config['self_loop'])
```

**é˜ˆå€¼æ ¡å‡†å‡½æ•°**ï¼ˆsrc/CurveSlice.py:56-63ï¼‰ï¼š
```python
@staticmethod
def fit_threshold(data: list):
    """éå†æ‰€æœ‰ç‰‡æ®µï¼Œæ ¡å‡†ä¸‰ç§ç±»å‹çš„é˜ˆå€¼"""
    # æ¯”è¾ƒç›¸é‚»ç‰‡æ®µï¼ˆè·³è¿‡æ¯æ¡è½¨è¿¹çš„é¦–ç‰‡æ®µï¼‰
    for i in range(len(data)):
        if data[i].isFront:  # å¦‚æœæ˜¯æŸæ¡è½¨è¿¹çš„ç¬¬ä¸€ä¸ªç‰‡æ®µï¼Œè·³è¿‡
            continue
        # å°†å½“å‰ç‰‡æ®µä¸å‰ä¸€ä¸ªç‰‡æ®µæ¯”è¾ƒï¼Œæ›´æ–°å…¨å±€é˜ˆå€¼
        Slice.fit_threshold_one(data[i].get_feature, data[i], data[i - 1])
    
    # éªŒè¯æ‰€æœ‰ç‰‡æ®µçš„æœ‰æ•ˆæ€§ï¼ˆæ ‡è®°æ‹Ÿåˆè¯¯å·®è¿‡å¤§çš„ç‰‡æ®µï¼‰
    for s in data:
        s.check_valid()
```

**å•å¯¹ç‰‡æ®µçš„é˜ˆå€¼æ ¡å‡†**ï¼ˆsrc/CurveSlice.py:32-54ï¼‰ï¼š
```python
@staticmethod
def fit_threshold_one(get_feature, data1, data2):
    """æ¯”è¾ƒä¸¤ä¸ªç›¸é‚»æ•°æ®æ®µï¼Œæ ¡å‡†ä¸‰ç§é˜ˆå€¼"""
    feature1 = data1.feature  # data1 çš„ NARX å‚æ•°
    feature2 = data2.feature  # data2 çš„ NARX å‚æ•°
    
    # 1ï¸âƒ£ æ‹Ÿåˆè¯¯å·®é˜ˆå€¼ï¼ˆFitErrorThresholdï¼‰
    # å°è¯•ç”¨å•ä¸€ NARX æ¨¡å‹åŒæ—¶æ‹Ÿåˆè¿™ä¸¤ä¸ªæ•°æ®æ®µ
    _, err, fit_order = get_feature([data1.data, data2.data],
                                  [data1.input_data, data2.input_data], is_list=True)
    
    # å¦‚æœæ‹Ÿåˆé˜¶æ•°æ²¡æœ‰å¢åŠ ï¼Œè¯´æ˜ä¸¤æ®µå¯èƒ½å±äºä¸åŒæ¨¡å¼ä½†åŠ¨æ€å¤æ‚åº¦ç›¸è¿‘
    if fit_order <= max(data1.fit_order, data2.fit_order):
        # æ›´æ–°é˜ˆå€¼ä¸ºå½“å‰è¯¯å·®çš„ 10%ï¼ˆå–æ‰€æœ‰è¯¯å·®çš„æœ€å°å€¼ï¼‰
        Slice.FitErrorThreshold = min(Slice.FitErrorThreshold,
                                      max(err) * Slice.ToleranceRatio)
        Slice.FitErrorThreshold = max(Slice.FitErrorThreshold, 1e-6)  # ä¸‹é™ä¿æŠ¤

    # åˆå§‹åŒ–é˜ˆå€¼åˆ—è¡¨ï¼ˆé•¿åº¦ä¸ç‰¹å¾å‘é‡ç»´åº¦ä¸€è‡´ï¼‰
    while len(Slice.RelativeErrorThreshold) < len(feature1):
        Slice.RelativeErrorThreshold.append(1e-1)
        Slice.AbsoluteErrorThreshold.append(1e-1)
    
    # 2ï¸âƒ£ å‚æ•°è·ç¦»é˜ˆå€¼ï¼ˆç”¨äº 'dis' èšç±»æ–¹æ³•ï¼‰
    idx = 0
    for v1, v2 in zip(feature1, feature2):
        relative_dis, dis = Slice.get_dis(v1, v2)
        # ç›¸å¯¹è·ç¦»é˜ˆå€¼ï¼šé€‚ç”¨äºå¤§æ•°å€¼å‚æ•°
        if relative_dis > 1e-4:
            Slice.RelativeErrorThreshold[idx] = \
                min(Slice.RelativeErrorThreshold[idx], relative_dis * Slice.ToleranceRatio)
        # ç»å¯¹è·ç¦»é˜ˆå€¼ï¼šé€‚ç”¨äºå°æ•°å€¼å‚æ•°
        if dis > 1e-4:
            Slice.AbsoluteErrorThreshold[idx] = \
                min(Slice.AbsoluteErrorThreshold[idx], max(dis * Slice.ToleranceRatio, 1e-6))
        idx += 1
    return True
```

**è·ç¦»è®¡ç®—å‡½æ•°**ï¼ˆsrc/CurveSlice.py:23-29ï¼‰ï¼š
```python
@staticmethod
def get_dis(v1, v2):
    """è®¡ç®—ä¸¤ä¸ªå‚æ•°å‘é‡çš„ç›¸å¯¹è·ç¦»å’Œç»å¯¹è·ç¦»"""
    dis = np.linalg.norm(v1 - v2, ord=1)  # L1 è·ç¦»ï¼ˆç»å¯¹è·ç¦»ï¼‰
    d1 = np.linalg.norm(v1, ord=1)
    d2 = np.linalg.norm(v2, ord=1)
    d_min = min(d1, d2)
    relative_dis = dis / max(d_min, 1e-6)  # ç›¸å¯¹è·ç¦» = å·®å€¼ / æœ€å°å€¼
    return relative_dis, dis
```

**ç‰‡æ®µæœ‰æ•ˆæ€§æ£€æŸ¥**ï¼ˆsrc/CurveSlice.py:65-68ï¼‰ï¼š
```python
def check_valid(self):
    """æ£€æŸ¥ç‰‡æ®µçš„æ‹Ÿåˆè¯¯å·®æ˜¯å¦è¶…è¿‡é˜ˆå€¼"""
    if self.valid and self.err > Slice.FitErrorThreshold:
        warnings.warn("Find a invalid segmentation!")
        self.valid = False  # æ ‡è®°ä¸ºæ— æ•ˆç‰‡æ®µï¼Œåç»­èšç±»æ—¶è·³è¿‡
```

#### 4.4 ä¸‰ç§é˜ˆå€¼çš„ä½œç”¨

| é˜ˆå€¼ç±»å‹ | å˜é‡å | ç”¨é€” | è®¡ç®—æ–¹å¼ |
|---------|--------|------|---------|
| **æ‹Ÿåˆè¯¯å·®é˜ˆå€¼** | `FitErrorThreshold` | åˆ¤æ–­å¤šä¸ªç‰‡æ®µèƒ½å¦è¢«å•ä¸€ NARX æ¨¡å‹æ‹Ÿåˆ | `min(ç›¸é‚»æ®µè”åˆæ‹Ÿåˆè¯¯å·®) Ã— 0.1` |
| **ç›¸å¯¹è·ç¦»é˜ˆå€¼** | `RelativeErrorThreshold` | åˆ¤æ–­å‚æ•°å‘é‡çš„ç›¸å¯¹å·®å¼‚ï¼ˆé€‚ç”¨å¤§æ•°å€¼ï¼‰ | `min(ç›¸é‚»æ®µå‚æ•°ç›¸å¯¹è·ç¦») Ã— 0.1` |
| **ç»å¯¹è·ç¦»é˜ˆå€¼** | `AbsoluteErrorThreshold` | åˆ¤æ–­å‚æ•°å‘é‡çš„ç»å¯¹å·®å¼‚ï¼ˆé€‚ç”¨å°æ•°å€¼ï¼‰ | `min(ç›¸é‚»æ®µå‚æ•°ç»å¯¹è·ç¦») Ã— 0.1` |

**é˜ˆå€¼é€‰æ‹©ç­–ç•¥**ï¼š
- é»˜è®¤ä½¿ç”¨ **æ‹Ÿåˆè¯¯å·®é˜ˆå€¼**ï¼ˆ`clustering_method = 'fit'`ï¼‰ï¼ŒåŸºäºç‰©ç†æ„ä¹‰ï¼Œæ›´é²æ£’
- å¯é€‰ä½¿ç”¨ **è·ç¦»é˜ˆå€¼**ï¼ˆ`clustering_method = 'dis'`ï¼‰ï¼Œè®¡ç®—æ›´å¿«ä½†å¯¹å™ªå£°æ•æ„Ÿ

#### 4.5 å·¥ä½œæœºåˆ¶ç¤ºä¾‹

å‡è®¾æœ‰ä¸€æ¡è½¨è¿¹è¢«åˆ†å‰²æˆ 5 ä¸ªç‰‡æ®µï¼š

```
ç‰‡æ®µåºåˆ—ï¼š  [æ®µ0]  [æ®µ1]  [æ®µ2]  [æ®µ3]  [æ®µ4]
æ¨¡å¼å½’å±ï¼š   A      B      A      C      A
```

**æ ¡å‡†è¿‡ç¨‹**ï¼š
```
æ¯”è¾ƒå¯¹1ï¼šæ®µ0 vs æ®µ1ï¼ˆæ¨¡å¼A vs Bï¼‰
  â†’ è”åˆæ‹Ÿåˆè¯¯å·® errâ‚ = 0.05
  â†’ FitErrorThreshold = min(1.0, 0.05 Ã— 0.1) = 0.005

æ¯”è¾ƒå¯¹2ï¼šæ®µ1 vs æ®µ2ï¼ˆæ¨¡å¼B vs Aï¼‰
  â†’ è”åˆæ‹Ÿåˆè¯¯å·® errâ‚‚ = 0.08
  â†’ FitErrorThreshold = min(0.005, 0.08 Ã— 0.1) = 0.005

æ¯”è¾ƒå¯¹3ï¼šæ®µ2 vs æ®µ3ï¼ˆæ¨¡å¼A vs Cï¼‰
  â†’ è”åˆæ‹Ÿåˆè¯¯å·® errâ‚ƒ = 0.12
  â†’ FitErrorThreshold = min(0.005, 0.12 Ã— 0.1) = 0.005

æ¯”è¾ƒå¯¹4ï¼šæ®µ3 vs æ®µ4ï¼ˆæ¨¡å¼C vs Aï¼‰
  â†’ è”åˆæ‹Ÿåˆè¯¯å·® errâ‚„ = 0.10
  â†’ FitErrorThreshold = min(0.005, 0.10 Ã— 0.1) = 0.005

æœ€ç»ˆé˜ˆå€¼ï¼šFitErrorThreshold = 0.005
```

**åç»­èšç±»æ—¶çš„åˆ¤æ–­**ï¼š
- åŒä¸€æ¨¡å¼å†…çš„ç‰‡æ®µï¼ˆå¦‚æ®µ0å’Œæ®µ2ï¼‰ï¼šæ‹Ÿåˆè¯¯å·® â‰ˆ 1e-10 << 0.005 âœ“ å½’ä¸ºåŒç±»
- ä¸åŒæ¨¡å¼çš„ç‰‡æ®µï¼ˆå¦‚æ®µ0å’Œæ®µ1ï¼‰ï¼šæ‹Ÿåˆè¯¯å·® â‰ˆ 0.05 >> 0.005 âœ— å½’ä¸ºä¸åŒç±»

#### 4.6 è®¾è®¡ä¼˜åŠ¿

1. **è‡ªé€‚åº”æ€§**ï¼šé˜ˆå€¼ä»æ•°æ®æœ¬èº«å­¦ä¹ ï¼Œæ— éœ€äººå·¥è°ƒå‚
2. **å°ºåº¦ä¸å˜æ€§**ï¼šé€šè¿‡ç›¸å¯¹è·ç¦»å’Œè¯¯å·®ç™¾åˆ†æ¯”ï¼Œé€‚åº”ä¸åŒé‡çº§çš„ç³»ç»Ÿ
3. **ç‰©ç†å¯è§£é‡Šæ€§**ï¼šé˜ˆå€¼ä»£è¡¨"æ¨¡å¼é—´æœ€å°å·®å¼‚çš„ 10%"ï¼Œæœ‰æ˜ç¡®çš„ç»Ÿè®¡æ„ä¹‰
4. **é²æ£’æ€§**ï¼šé€šè¿‡ `min()` æ“ä½œé€‰æ‹©æœ€ä¸¥æ ¼çš„é˜ˆå€¼ï¼Œé™ä½è¯¯åˆ†ç±»é£é™©
5. **å®¹é”™æ€§**ï¼š10% çš„å®¹å¿æ¯”ä¾‹å…è®¸å™ªå£°å’Œå°å¹…æ³¢åŠ¨

**å…³é”®æ´å¯Ÿ**ï¼š
> é˜ˆå€¼æ ¡å‡†çš„æœ¬è´¨æ˜¯ä¸€ç§**"å¯¹æ¯”å­¦ä¹ "**â€”â€”é€šè¿‡æ¯”è¾ƒç¡®å®šå±äºä¸åŒæ¨¡å¼çš„ç‰‡æ®µå¯¹ï¼Œå­¦ä¹ "ä»€ä¹ˆæ˜¯ä¸åŒ"çš„æ ‡å‡†ï¼Œç„¶åå°†è¿™ä¸ªæ ‡å‡†ç¼©å° 10 å€ä½œä¸ºèšç±»çš„è¾¹ç•Œã€‚è¿™ç§æ–¹æ³•å·§å¦™åœ°å°†"æ— ç›‘ç£èšç±»"é—®é¢˜è½¬åŒ–ä¸º"å¼±ç›‘ç£å­¦ä¹ "é—®é¢˜ï¼ˆæ—¶åºä¿¡æ¯æä¾›äº†å¼±æ ‡ç­¾ï¼‰ã€‚

#### 4.7 ä¸åˆ†å‰²é˜¶æ®µé˜ˆå€¼çš„å¯¹æ¯”

| ç‰¹æ€§ | åˆ†å‰²é˜¶æ®µï¼ˆæœºå™¨çº§é˜ˆå€¼ï¼‰ | èšç±»é˜¶æ®µï¼ˆåŠ¨æ€é˜ˆå€¼ï¼‰ |
|------|----------------------|---------------------|
| **ç›®çš„** | æ£€æµ‹æ¨¡å¼åˆ‡æ¢çš„ç²¾ç¡®æ—¶åˆ» | åˆ¤æ–­ç‰‡æ®µæ˜¯å¦å±äºåŒä¸€æ¨¡å¼ |
| **é˜ˆå€¼æ¥æº** | æ•°å­¦å®šä¹‰ `1e-6 Ã— dt Ã— max(data)` | æ•°æ®é©±åŠ¨å­¦ä¹  |
| **ä¸¥æ ¼ç¨‹åº¦** | æä¸¥æ ¼ï¼ˆè¯¯å·® ~1e-10 æ‰é€šè¿‡ï¼‰ | ç›¸å¯¹å®½æ¾ï¼ˆè¯¯å·® < 0.005 å¯é€šè¿‡ï¼‰ |
| **ç‰©ç†æ„ä¹‰** | å•ä¸€æ¨¡å‹å®Œç¾æ‹Ÿåˆçš„æé™ | æ¨¡å¼é—´å·®å¼‚çš„å®¹å¿è¾¹ç•Œ |

**æµç¨‹ç¤ºæ„**ï¼š
```
åŸå§‹æ•°æ®
   â†“
[åˆ†å‰²é˜¶æ®µ] ä½¿ç”¨æœºå™¨çº§é˜ˆå€¼ï¼ˆä¸¥æ ¼ï¼‰
   â†“ æ£€æµ‹åˆ°å˜åŒ–ç‚¹
åˆ‡åˆ†åçš„ç‰‡æ®µåˆ—è¡¨ (slice_data)
   â†“
[æ ¡å‡†é˜¶æ®µ] å­¦ä¹ åŠ¨æ€é˜ˆå€¼ï¼ˆè‡ªé€‚åº”ï¼‰ â† æœ¬èŠ‚é‡ç‚¹
   â†“ è®¡ç®— FitErrorThreshold
[èšç±»é˜¶æ®µ] ä½¿ç”¨åŠ¨æ€é˜ˆå€¼ï¼ˆå®½æ¾ï¼‰
   â†“
æ¨¡å¼è¯†åˆ«ç»“æœ
```

### 5. åŸºäºæ‹Ÿåˆèƒ½åŠ›çš„èšç±»ç®—æ³•

è¿™æ˜¯æ–¹æ³•çš„æ ¸å¿ƒåˆ›æ–°ï¼š**ä¸æ˜¯æ¯”è¾ƒå‚æ•°å‘é‡çš„è·ç¦»ï¼Œè€Œæ˜¯æµ‹è¯•"èƒ½å¦ç”¨åŒä¸€ç»„ NARX å‚æ•°æ‹Ÿåˆä¸åŒæ•°æ®æ®µ"**ã€‚èšç±»ç®—æ³•å®ç°äº†è®ºæ–‡ä¸­çš„**å¯åˆå¹¶æ€§ï¼ˆMergeableï¼‰**å’Œ**æœ€å°å¯åˆå¹¶æ€§ï¼ˆMinimally Mergeableï¼‰**æ¦‚å¿µã€‚

> ğŸ’¡ **è¯¦ç»†åˆ†ææ–‡æ¡£**ï¼šå®Œæ•´çš„èšç±»ç®—æ³•åˆ†æè¯·å‚è§ [clustering_detailed_analysis.md](./clustering_detailed_analysis.md)ï¼ŒåŒ…å«ç†è®ºåŸºç¡€ã€ç®—æ³•æµç¨‹ã€æ•°å­¦å…¬å¼ã€å¤æ‚åº¦åˆ†æå’Œå¯è§†åŒ–ç¤ºä¾‹ã€‚

#### 5.1 ç†è®ºåŸºç¡€

**è®ºæ–‡å®šä¹‰**ï¼ˆDefinition 11 & 13ï¼‰ï¼š

- **å¯åˆå¹¶æ€§ï¼ˆMergeable Tracesï¼‰**ï¼šä¸€ç»„è½¨è¿¹æ®µé›†åˆ $S$ å¯¹äºæ¨¡æ¿ NARX æ¨¡å‹ $N$ æ˜¯å¯åˆå¹¶çš„ï¼Œå½“ä¸”ä»…å½“å­˜åœ¨ $N \in \langle N \rangle$ ä½¿å¾— $N \models S$
- **æœ€å°å¯åˆå¹¶æ€§ï¼ˆMinimally Mergeableï¼‰**ï¼šæ‹Ÿåˆ $S$ æ‰€éœ€çš„æœ€å° NARX é˜¶æ•° $k_S$ ç­‰äºæ‹Ÿåˆä»»æ„å•ä¸ªæ®µçš„é˜¶æ•°

**åˆ¤æ–­æ¡ä»¶**ï¼š
$$\text{test\_set}(s_i, S_q) = (\text{order\_condition}) \land (\max(\text{err}) < \theta_{\text{fit}})$$

å…¶ä¸­ï¼š
- **é˜¶æ•°æ¡ä»¶**ï¼š$k_{\text{combined}} \leq \max(k_{s_i}, \min_{s \in S_q} k_s)$ï¼ˆæœ€å°å¯åˆå¹¶æ€§ï¼‰
- **è¯¯å·®æ¡ä»¶**ï¼š$\max(\text{err}) < \text{FitErrorThreshold}$ï¼ˆåŠ¨æ€æ ¡å‡†é˜ˆå€¼ï¼‰

#### 5.2 ç®—æ³•æ ¸å¿ƒï¼štest_set å‡½æ•°

**æ ¸å¿ƒæµ‹è¯•å‡½æ•°** (src/CurveSlice.py:90-104)ï¼š

```python
def test_set(self, other_list):
    """æµ‹è¯•å½“å‰æ•°æ®æ®µèƒ½å¦ä¸ other_list ä¸­çš„æ®µå…±åŒæ‹Ÿåˆ"""
    # æ”¶é›†å‚è€ƒæ®µçš„æ•°æ®å’Œæ‹Ÿåˆé˜¶æ•°
    data, input_data, other_fit_order = [], [], None
    for s in other_list:
        data.append(s.data)
        input_data.append(s.input_data)
        other_fit_order = min(other_fit_order, s.fit_order) if other_fit_order else s.fit_order
    
    # å°è¯•ç”¨å•ä¸€ NARX æ¨¡å‹æ‹Ÿåˆå½“å‰æ®µ+æ‰€æœ‰å‚è€ƒæ®µ
    _, err, fit_order = self.get_feature(
        [self.data] + data,
        [self.input_data] + input_data,
        is_list=True
    )
    
    # åˆ¤æ–­æ¡ä»¶1ï¼šæ‹Ÿåˆé˜¶æ•°ä¸å¢åŠ ï¼ˆæœ€å°å¯åˆå¹¶æ€§ï¼‰
    order_condition = all(
        fit_order[i] <= max(self.fit_order[i], other_fit_order[i])
        for i in range(len(fit_order))
    )
    
    # åˆ¤æ–­æ¡ä»¶2ï¼šæ‹Ÿåˆè¯¯å·®å°äºæ ¡å‡†çš„é˜ˆå€¼
    return order_condition and max(err) < Slice.FitErrorThreshold
```

**ä¸ºä»€ä¹ˆè¿™æ ·è®¾è®¡æœ‰æ•ˆï¼Ÿ**

å¦‚æœä¸¤ä¸ªæ•°æ®æ®µæ¥è‡ªåŒä¸€ä¸ªåŠ¨åŠ›å­¦æ¨¡å¼ $q$ï¼Œå®ƒä»¬éƒ½æ»¡è¶³ç›¸åŒçš„ NARX æ–¹ç¨‹ï¼š
$$\vec{x}[\tau] = F_q(\vec{x}[\tau-1], ..., \vec{x}[\tau-k], \vec{u}[\tau])$$

å› æ­¤ç”¨å•ä¸€ NARX æ¨¡å‹è”åˆæ‹Ÿåˆå®ƒä»¬åº”è¯¥ï¼š
1. **ä¸éœ€è¦å¢åŠ æ¨¡å‹é˜¶æ•°**ï¼šåŒä¸€ç‰©ç†è§„å¾‹ä¸‹ï¼Œæ—¶é—´ä¾èµ–æ·±åº¦åº”è¯¥ä¸€è‡´
2. **æ‹Ÿåˆè¯¯å·®ä¿æŒåœ¨å®¹å¿èŒƒå›´å†…**ï¼šåŒä¸€åŠ¨åŠ›å­¦æ–¹ç¨‹äº§ç”Ÿçš„æ•°æ®åº”è¯¥èƒ½è¢«ç»Ÿä¸€æè¿°

è¿™ç§åˆ¤æ–­æ–¹å¼**ç›´æ¥åŸºäºç‰©ç†æ„ä¹‰**ï¼ˆåŠ¨åŠ›å­¦æ–¹ç¨‹çš„ä¸€è‡´æ€§ï¼‰ï¼Œè€Œä¸æ˜¯å‚æ•°ç©ºé—´çš„å‡ ä½•è·ç¦»ï¼Œå› æ­¤å¯¹å™ªå£°å’Œå‚æ•°æ‰°åŠ¨æ›´é²æ£’ã€‚

#### 5.3 ä¸¤ç§èšç±»æ–¹æ³•

**æ–¹æ³•Aï¼šè·ç¦»æ–¹æ³• (`Method == 'dis'`)** - åŸºäºå‚æ•°å‘é‡çš„ L1 è·ç¦»

```python
if Slice.Method == 'dis':
    for j in range(i):
        if (data[j].mode != last_mode) and (data[i] & data[j]):
            data[i].setMode(data[j].mode)
            break
```

**`&` è¿ç®—ç¬¦**ï¼šæ¯”è¾ƒç‰¹å¾å‘é‡çš„ç›¸å¯¹è·ç¦»å’Œç»å¯¹è·ç¦»
$$v_1 \& v_2 = \text{True} \iff \forall i: (\text{relative\_dis}_i \leq \theta_{\text{rel}}[i]) \lor (\text{dis}_i \leq \theta_{\text{abs}}[i])$$

**æ–¹æ³•Bï¼šæ‹Ÿåˆæ–¹æ³• (`Method == 'fit'`)** - **æ¨èæ–¹æ³•**ï¼ŒåŸºäº NARX å¯åˆå¹¶æ€§

```python
else:  # 'fit' æ–¹æ³•
    fit_cnt = 0
    for idx, val in mode_dict.items():
        # æµ‹è¯•ï¼šå½“å‰æ•°æ®æ®µèƒ½å¦ä¸è¯¥æ¨¡å¼çš„ä»£è¡¨æ®µåˆå¹¶æ‹Ÿåˆï¼Ÿ
        if idx != last_mode and data[i].test_set(val):
            data[i].mode = idx
            fit_cnt += 1
    
    # æ ¹æ®åŒ¹é…ç»“æœåˆ†é…
    if fit_cnt == 1:
        if len(mode_dict[data[i].mode]) < 3:
            mode_dict[data[i].mode].append(data[i])  # æ·»åŠ ä¸ºä»£è¡¨æ®µ
    elif fit_cnt > 1:
        delay_list.append(data[i])  # æ­§ä¹‰ï¼Œå»¶è¿Ÿå¤„ç†
```

**å…³é”®è®¾è®¡**ï¼š
- **ä»£è¡¨æ®µé™åˆ¶**ï¼šæ¯ä¸ªæ¨¡å¼æœ€å¤šä¿ç•™3ä¸ªä»£è¡¨æ®µï¼Œå¹³è¡¡å‡†ç¡®æ€§å’Œæ•ˆç‡
- **å»¶è¿Ÿå¤„ç†**ï¼šæ­§ä¹‰æƒ…å†µï¼ˆåŒ¹é…å¤šä¸ªæ¨¡å¼ï¼‰å»¶è¿Ÿåˆ°ç¬¬äºŒé˜¶æ®µï¼Œåˆ©ç”¨æ›´å®Œæ•´çš„ä¸Šä¸‹æ–‡
- **æ—¶åºçº¦æŸ**ï¼šé€šè¿‡ `last_mode` é¿å…è¿ç»­åˆ†æ®µè¢«åˆ†åˆ°åŒä¸€æ¨¡å¼ï¼ˆé™¤é `self_loop=True`ï¼‰

#### 5.4 ä¸¤ç§æ–¹æ³•å¯¹æ¯”

| ç‰¹æ€§ | è·ç¦»æ–¹æ³• (`dis`) | æ‹Ÿåˆæ–¹æ³• (`fit`) |
|------|-----------------|------------------|
| **åˆ¤æ–­ä¾æ®** | å‚æ•°å‘é‡çš„ L1 è·ç¦» | NARX æ¨¡å‹çš„å¯åˆå¹¶æ€§ |
| **ç†è®ºåŸºç¡€** | å‡ ä½•è·ç¦» | ç‰©ç†æ„ä¹‰ï¼ˆæœ€å°å¯åˆå¹¶æ€§ï¼‰ |
| **è®¡ç®—å¤æ‚åº¦** | ä½ï¼ˆ$O(d)$ï¼‰ | ä¸­ç­‰ï¼ˆ$O(w \cdot d^2)$ï¼‰ |
| **é²æ£’æ€§** | å¯¹å™ªå£°æ•æ„Ÿ | å¯¹å™ªå£°é²æ£’ |
| **å»¶è¿Ÿå¤„ç†** | æ—  | æœ‰ï¼ˆç¬¬äºŒé˜¶æ®µï¼‰ |
| **æ¨èåœºæ™¯** | å¿«é€ŸåŸå‹ | ç”Ÿäº§ç¯å¢ƒ |

**æ¨èä½¿ç”¨ `fit` æ–¹æ³•**ï¼šç›´æ¥å¯¹åº”è®ºæ–‡ç†è®ºï¼ŒåŸºäºç‰©ç†æ„ä¹‰ï¼Œå¯¹å™ªå£°é²æ£’ã€‚

**ä»£ç å®ç°** (src/Clustering.py:4-61)ï¼š
```python
def clustering(data: list[Slice], self_loop=False):
    """
    åŸºäº NARX æ‹Ÿåˆèƒ½åŠ›çš„èšç±»ç®—æ³•

    æ ¸å¿ƒæ€æƒ³ï¼š
        - èƒ½è¢«åŒä¸€ç»„ NARX æ¨¡å‹æ‹Ÿåˆçš„æ•°æ®æ®µ â†’ åŒä¸€æ¨¡å¼
        - ç»´æŠ¤ mode_dict[mode_id] = [ä»£è¡¨æ€§æ•°æ®æ®µåˆ—è¡¨]
    """
    tot_mode = 1
    last_mode = None
    mode_dict = {}  # å­˜å‚¨æ¯ä¸ªæ¨¡å¼çš„ä»£è¡¨æ€§æ•°æ®æ®µ
    delay_list = []  # æš‚æ—¶æ— æ³•åˆ†ç±»çš„æ­§ä¹‰æ•°æ®æ®µ

    for i in range(len(data)):
        data[i].idx = i
        if not data[i].valid:
            continue
        if data[i].isFront:
            last_mode = None

        # æ–¹æ³•1ï¼šåŸºäºå‚æ•°è·ç¦»çš„èšç±»ï¼ˆ'dis' æ–¹æ³•ï¼‰
        if Slice.Method == 'dis':
            for j in range(i):
                if (data[j].mode != last_mode) and (data[i] & data[j]):
                    data[i].setMode(data[j].mode)
                if data[i].mode is not None:
                    break
        # æ–¹æ³•2ï¼šåŸºäºæ‹Ÿåˆèƒ½åŠ›çš„èšç±»ï¼ˆ'fit' æ–¹æ³•ï¼Œé»˜è®¤æ¨èï¼‰
        else:
            fit_cnt = 0
            # éå†å·²è¯†åˆ«çš„æ‰€æœ‰æ¨¡å¼
            for idx, val in mode_dict.items():
                # æµ‹è¯•ï¼šå½“å‰æ•°æ®æ®µèƒ½å¦è¢«è¯¥æ¨¡å¼çš„ä»£è¡¨æ®µæ‹Ÿåˆï¼Ÿ
                if idx != last_mode and data[i].test_set(val):
                    data[i].mode = idx
                    fit_cnt += 1
                # å¤„ç†äºŒé˜¶æ®µåŒ¹é…çš„ç‰¹æ®Šæƒ…å†µ
                elif len(val) == 2:
                    if data[i].test_set([val[0]]) or data[i].test_set([val[1]]):
                        delay_list.append(val[-1])
                        mode_dict[idx].pop()
                        fit_cnt = 2

            # æƒ…å†µ1ï¼šæ°å¥½åŒ¹é…ä¸€ä¸ªæ¨¡å¼
            if fit_cnt == 1:
                if len(mode_dict[data[i].mode]) < 3:
                    mode_dict[data[i].mode].append(data[i])  # æ·»åŠ ä¸ºä»£è¡¨æ®µ
            # æƒ…å†µ2ï¼šåŒ¹é…å¤šä¸ªæ¨¡å¼ï¼ˆæ­§ä¹‰ï¼‰
            elif fit_cnt > 1:
                delay_list.append(data[i])
                data[i].mode = -1

        # æƒ…å†µ3ï¼šä¸åŒ¹é…ä»»ä½•ç°æœ‰æ¨¡å¼ â†’ åˆ›å»ºæ–°æ¨¡å¼
        if data[i].mode is None:
            data[i].mode = tot_mode
            mode_dict[tot_mode] = [data[i]]
            tot_mode += 1

        if not self_loop:
            last_mode = data[i].mode

    # 'dis' æ–¹æ³•ä¸éœ€è¦ç¬¬äºŒé˜¶æ®µå¤„ç†ï¼Œç›´æ¥è¿”å›
    if Slice.Method != 'fit':
        return

    # ç¬¬äºŒé˜¶æ®µï¼šå¤„ç†æ­§ä¹‰æ•°æ®æ®µï¼ˆä»…ç”¨äº 'fit' æ–¹æ³•ï¼‰
    for s in delay_list:
        for idx, val in mode_dict.items():
            # åˆ©ç”¨æ—¶åºä¿¡æ¯ï¼šè·³è¿‡å‰ä¸€æ®µçš„æ¨¡å¼ï¼ˆé¿å…è‡ªç¯ï¼‰
            if not s.isFront and data[s.idx - 1].mode == idx:
                continue
            if s.test_set(val):
                s.mode = idx
                if len(val) < 3:
                    mode_dict[idx].append(s)
                break
        # ä»æ— æ³•åŒ¹é… â†’ åˆ›å»ºæ–°æ¨¡å¼
        if s.mode is None or s.mode == -1:
            s.mode = tot_mode
            mode_dict[tot_mode] = [s]
            tot_mode += 1
```

**test_set å‡½æ•°** (src/CurveSlice.py:90-104)ï¼š
```python
def test_set(self, other_list):
    """æµ‹è¯•å½“å‰æ•°æ®æ®µèƒ½å¦è¢« other_list ä¸­çš„æ®µå…±åŒæ‹Ÿåˆ"""
    data, input_data, other_fit_order = [], [], None

    # æ”¶é›†å‚è€ƒæ®µçš„æ•°æ®
    for s in other_list:
        data.append(s.data)
        input_data.append(s.input_data)
        if other_fit_order is None:
            other_fit_order = copy.copy(s.fit_order)
        else:
            other_fit_order = min(other_fit_order, s.fit_order)

    # å°è¯•ç”¨å•ä¸€ NARX æ¨¡å‹æ‹Ÿåˆå½“å‰æ®µ+æ‰€æœ‰å‚è€ƒæ®µ
    _, err, fit_order = self.get_feature([self.data] + data,
                                        [self.input_data] + input_data,
                                        is_list=True)

    # åˆ¤æ–­æ¡ä»¶ï¼š
    # 1. æ‹Ÿåˆé˜¶æ•°ä¸å¢åŠ ï¼ˆæ¨¡å‹å¤æ‚åº¦ä¸å˜ï¼‰
    # 2. æ‹Ÿåˆè¯¯å·®å°äºæ ¡å‡†çš„é˜ˆå€¼
    order_condition = True
    for i in range(len(fit_order)):
        order_condition = order_condition and \
                         fit_order[i] <= max(self.fit_order[i], other_fit_order[i])

    return order_condition and max(err) < Slice.FitErrorThreshold
```

**ä¸ºä»€ä¹ˆè¿™æ ·è®¾è®¡æœ‰æ•ˆï¼Ÿ**

å¦‚æœä¸¤ä¸ªæ•°æ®æ®µæ¥è‡ªåŒä¸€ä¸ªåŠ¨åŠ›å­¦æ¨¡å¼ï¼Œé‚£ä¹ˆç”¨å•ä¸€ NARX æ¨¡å‹è”åˆæ‹Ÿåˆå®ƒä»¬åº”è¯¥ï¼š
1. **ä¸éœ€è¦å¢åŠ æ¨¡å‹é˜¶æ•°**ï¼šåŒä¸€ç‰©ç†è§„å¾‹ä¸‹ï¼Œæ—¶é—´ä¾èµ–æ·±åº¦åº”è¯¥ä¸€è‡´
2. **æ‹Ÿåˆè¯¯å·®ä¿æŒåœ¨å®¹å¿èŒƒå›´å†…**ï¼šåŒä¸€åŠ¨åŠ›å­¦æ–¹ç¨‹äº§ç”Ÿçš„æ•°æ®åº”è¯¥èƒ½è¢«ç»Ÿä¸€æè¿°

è¿™ç§åˆ¤æ–­æ–¹å¼**ç›´æ¥åŸºäºç‰©ç†æ„ä¹‰**ï¼Œè€Œä¸æ˜¯å‚æ•°ç©ºé—´çš„å‡ ä½•è·ç¦»ã€‚

**èšç±»è¿‡ç¨‹ç¤ºæ„**ï¼š
```
æ®µ1 æ®µ2 æ®µ3 æ®µ4 æ®µ5 æ®µ6
 â†“   â†“   â†“   â†“   â†“   â†“
[æ®µ1] â†’ æ¨¡å¼1
[æ®µ2] test_set([æ®µ1]) â†’ é€šè¿‡ â†’ æ¨¡å¼1
[æ®µ3] test_set([æ®µ1,æ®µ2]) â†’ å¤±è´¥ â†’ æ¨¡å¼2
[æ®µ4] test_set([æ®µ1,æ®µ2]) â†’ é€šè¿‡ â†’ æ¨¡å¼1
[æ®µ5] test_set([æ®µ3]) â†’ é€šè¿‡ â†’ æ¨¡å¼2
[æ®µ6] test_set([æ®µ1,æ®µ2,æ®µ4]) â†’ å¤±è´¥ â†’ test_set([æ®µ3,æ®µ5]) â†’ å¤±è´¥ â†’ æ¨¡å¼3
```

### 6. å®Œæ•´çš„è¯†åˆ«æµç¨‹

**ä¸»æµç¨‹ä»£ç ** (main.py:23-47)ï¼š
```python
def run(data_list, input_data, config, evaluation: Evaluation):
    """æ··åˆç³»ç»Ÿè¯†åˆ«ä¸»æµç¨‹"""
    input_data = np.array(input_data)

    # 1. åˆå§‹åŒ– NARX ç‰¹å¾æå–å™¨
    get_feature = FeatureExtractor(len(data_list[0]), len(input_data[0]),
                                   order=config['order'], dt=config['dt'],
                                   minus=config['minus'],
                                   need_bias=config['need_bias'],
                                   other_items=config['other_items'])

    Slice.clear()
    slice_data = []
    chp_list = []

    # 2. åˆ†å‰²ï¼šå¯¹æ¯æ¡è®­ç»ƒè½¨è¿¹æ£€æµ‹åˆ‡æ¢ç‚¹
    for data, input_val in zip(data_list, input_data):
        change_points = find_change_point(data, input_val, get_feature,
                                        w=config['window_size'])
        chp_list.append(change_points)
        print("ChP:\t", change_points)
        slice_curve(slice_data, data, input_val, change_points, get_feature)

    evaluation.submit(chp=chp_list)
    evaluation.recording_time("change_points")

    # 3. é˜ˆå€¼æ ¡å‡†
    Slice.Method = config['clustering_method']
    Slice.fit_threshold(slice_data)

    # 4. èšç±»ï¼šè¯†åˆ«æ¨¡å¼
    clustering(slice_data, config['self_loop'])
    evaluation.recording_time("clustering")

    # 5. å­¦ä¹ å®ˆå«æ¡ä»¶ï¼ˆæ¨¡å¼åˆ‡æ¢è§„åˆ™ï¼‰
    adj = guard_learning(slice_data, get_feature, config)
    evaluation.recording_time("guard_learning")

    # 6. æ„å»ºæ··åˆè‡ªåŠ¨æœº
    sys = build_system(slice_data, adj, get_feature)
    evaluation.stop("total")
    evaluation.submit(slice_data=slice_data)

    return sys, slice_data
```

**æµç¨‹æ€»ç»“**ï¼š
```
è¾“å…¥æ•°æ®
   â†“
[1] æ»‘åŠ¨çª—å£ + NARXæ‹Ÿåˆ â†’ æ£€æµ‹åˆ‡æ¢ç‚¹ â†’ æ•°æ®æ®µåˆ—è¡¨
   â†“
[2] åŠ¨æ€æ ¡å‡†é˜ˆå€¼ â† ç›¸é‚»æ®µæ‹Ÿåˆè¯¯å·®ç»Ÿè®¡
   â†“
[3] åŸºäºæ‹Ÿåˆèƒ½åŠ›çš„èšç±» â†’ æ¨¡å¼è¯†åˆ«
   â†“
[4] SVMå­¦ä¹ å®ˆå«æ¡ä»¶ â†’ åˆ‡æ¢è§„åˆ™
   â†“
[5] æ„å»ºæ··åˆè‡ªåŠ¨æœº â† æ¨¡å¼+åˆ‡æ¢è§„åˆ™+é‡ç½®å‡½æ•°
   â†“
è¾“å‡ºï¼šå¯ä»¿çœŸçš„æ··åˆç³»ç»Ÿæ¨¡å‹
```

### 7. å®éªŒé…ç½®ç¤ºä¾‹

**Duffing æŒ¯å­é…ç½®** (automata/non_linear/duffing.json)ï¼š
```json
{
  "config": {
    "order": 3,                    // NARX æ¨¡å‹é˜¶æ•°
    "window_size": 10,             // æ»‘åŠ¨çª—å£å¤§å°
    "clustering_method": "fit",    // èšç±»æ–¹æ³•ï¼š"fit"ï¼ˆæ‹Ÿåˆèƒ½åŠ›ï¼‰æˆ– "dis"ï¼ˆè·ç¦»ï¼‰
    "need_bias": true,             // æ˜¯å¦åŒ…å«åç½®é¡¹
    "need_reset": false,           // æ˜¯å¦å­¦ä¹ çŠ¶æ€é‡ç½®å‡½æ•°
    "kernel": "linear",            // SVM æ ¸å‡½æ•°
    "svm_c": 1e6,                  // SVM æ­£åˆ™åŒ–å‚æ•°
    "other_items": "",             // è‡ªå®šä¹‰éçº¿æ€§é¡¹ï¼ˆå¦‚ "x[1]*x[2]"ï¼‰
    "minus": false,                // æ˜¯å¦è‡ªåŠ¨å‡å°‘æ¨¡å‹é˜¶æ•°
    "self_loop": false,            // æ˜¯å¦å…è®¸è‡ªç¯ï¼ˆåŒä¸€æ¨¡å¼å†…è·³è½¬ï¼‰
    "class_weight": 1.0,           // SVM ç±»åˆ«æƒé‡
    "dt": 0.01,                    // é‡‡æ ·æ—¶é—´é—´éš”
    "total_time": 10               // ä»¿çœŸæ€»æ—¶é•¿
  }
}
```

**å…³é”®å‚æ•°è¯´æ˜**ï¼š
- `order`ï¼šå†³å®šäº† NARX æ¨¡å‹èƒ½æ•æ‰å¤šé•¿çš„æ—¶é—´ä¾èµ–ï¼ˆé€šå¸¸ 2-5ï¼‰
- `window_size`ï¼šçª—å£è¶Šå¤§ï¼Œå¯¹å™ªå£°è¶Šé²æ£’ï¼Œä½†å¯èƒ½é”™è¿‡çŸ­æš‚çš„æ¨¡å¼
- `clustering_method = "fit"`ï¼šæ¨èè®¾ç½®ï¼ŒåŸºäºç‰©ç†æ„ä¹‰çš„æ‹Ÿåˆèƒ½åŠ›èšç±»
- `other_items`ï¼šå¯æ‰©å±•æ€§æ¥å£ï¼Œç”¨äºæ·»åŠ é¢†åŸŸçŸ¥è¯†çš„éçº¿æ€§é¡¹

### æ–¹æ³•å…¬å¼åŒ–

**ç³»ç»Ÿæ¨¡å¼è¯†åˆ« = Â¬ (å•ä¸€ NARX æ¨¡å‹ æ‹Ÿåˆ æ•°æ®æ®µ)** + **(æ¨¡å‹å‚æ•°é›† â‰ˆ æ¨¡å¼æ ‡è¯†)**

è¿™ä¸ªå…¬å¼è¡¨è¾¾äº†ï¼š
1.  æ¨¡å¼çš„**åˆ‡æ¢ç‚¹**é€šè¿‡åˆ¤æ–­â€œå•ä¸€NARXæ¨¡å‹æ— æ³•æ‹Ÿåˆå½“å‰æ•°æ®æ®µâ€æ¥ç¡®å®šï¼ˆç”¨é€»è¾‘éâ€œÂ¬â€è¡¨ç¤ºï¼‰ã€‚
2.  æ¨¡å¼çš„**ç±»åˆ«**é€šè¿‡â€œèƒ½å¤ŸæˆåŠŸæ‹ŸåˆæŸæ•°æ®æ®µçš„æ¨¡å‹å‚æ•°é›†â€æ¥å®šä¹‰å’Œèšç±»ã€‚

### æœ€ç»ˆåŒé‡æ€»ç»“

*   **ä¸€å¥è¯æ€»ç»“ (æ ¸å¿ƒä»·å€¼)**
    ä¸ºäº†è§£å†³ä¼ ç»Ÿæ–¹æ³•ä¾èµ–è„†å¼±çš„å¯¼æ•°é˜ˆå€¼æ¥è¯†åˆ«æ··åˆç³»ç»Ÿæ¨¡å¼åˆ‡æ¢çš„æ ¹æœ¬é—®é¢˜ï¼Œè¯¥ç ”ç©¶æå‡ºäº†ä¸€ç§åˆ›æ–°çš„åˆ‡å…¥è§†è§’â€”â€”å³æ¨¡å¼åˆ‡æ¢çš„æœ¬è´¨æ˜¯å•ä¸€åŠ¨æ€æ¨¡å‹çš„æ‹Ÿåˆå¤±æ•ˆâ€”â€”å¹¶ä»¥æ­¤ä¸ºåŸºç¡€ï¼Œé€šè¿‡å°†éçº¿æ€§è‡ªå›å½’ï¼ˆNARXï¼‰æ¨¡å‹çš„æ‹Ÿåˆæ®‹å·®ä½œä¸ºä¸€ç§ç»Ÿä¸€ã€æ— é˜ˆå€¼çš„å†…åœ¨æ ‡å‡†ï¼ŒæˆåŠŸåœ°å®ç°äº†å¯¹é«˜é˜¶éçº¿æ€§æ··åˆç³»ç»Ÿç»“æ„ä¸åŠ¨æ€çš„ç²¾ç¡®æ¨æ–­ã€‚

*   **ä¸€å¥è¯æ€»ç»“ (å¤§ç™½è¯ç‰ˆ)**
    è¦åˆ¤æ–­ä¸€ä¸ªæœºå™¨äººå•¥æ—¶å€™åˆ‡æ¢äº†æ–°ä»»åŠ¡ï¼Œåˆ«è´¹åŠ²å»çœ‹å®ƒçš„é€Ÿåº¦æ˜¯ä¸æ˜¯çªç„¶å˜å¿«äº†ï¼Œä½ åªè¦ä¸€ç›´ç”¨åŒä¸€ä¸ªâ€œè¡Œä¸ºè¯´æ˜ä¹¦â€å»å¥—å®ƒçš„åŠ¨ä½œï¼Œå½“è¯´æ˜ä¹¦çªç„¶å¯¹ä¸ä¸Šå·çš„é‚£ä¸€åˆ»ï¼Œå°±è¯´æ˜å®ƒæ¢ä»»åŠ¡äº†ã€‚