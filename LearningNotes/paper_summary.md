
### æ ¸å¿ƒè¦ç´ åˆ†æ

*   **æ ¹æœ¬é—®é¢˜**
    ä¼ ç»Ÿä¸Šï¼Œä»æ•°æ®ä¸­è¯†åˆ«â€œæ··åˆç³»ç»Ÿâ€ï¼ˆå³ä¼šåœ¨ä¸åŒå·¥ä½œæ¨¡å¼é—´åˆ‡æ¢çš„ç³»ç»Ÿï¼‰ä¾èµ–äºæ£€æµ‹å…¶ä¿¡å·çš„â€œå¯¼æ•°çªå˜â€ã€‚è¿™ç§æ–¹æ³•ä¸ä»…å¯¹å™ªå£°æ•æ„Ÿï¼Œæ›´å…³é”®çš„æ˜¯éœ€è¦äººä¸ºè®¾å®šä¸€ä¸ªéš¾ä»¥æŠŠæ¡çš„â€œçªå˜é˜ˆå€¼â€â€”â€”é˜ˆå€¼å¤ªé«˜ä¼šæ¼æ‰çœŸå®çš„æ¨¡å¼åˆ‡æ¢ï¼Œå¤ªä½åˆ™ä¼šå¼•å…¥å¤§é‡è™šå‡çš„åˆ‡æ¢ç‚¹ï¼Œå°¤å…¶å¯¹äºå¤æ‚çš„éçº¿æ€§ç³»ç»Ÿï¼Œæ­¤çŸ›ç›¾å‡ ä¹æ— è§£ã€‚

*   **åˆ‡å…¥è§†è§’**
    æœ¬æ–‡æå‡ºäº†ä¸€ä¸ªæ ¹æœ¬æ€§çš„è§†è§’è½¬å˜ï¼šæ¨¡å¼åˆ‡æ¢çš„æœ¬è´¨ç‰¹å¾å¹¶éä¿¡å·çš„â€œå¯¼æ•°å‰§å˜â€ï¼Œè€Œæ˜¯ç³»ç»ŸèƒŒåâ€œåŠ¨æ€è§„å¾‹ï¼ˆdynamic modelï¼‰çš„ä¸å†é€‚ç”¨â€ã€‚å³ï¼Œåªè¦ç³»ç»Ÿéµå¾ªåŒä¸€å¥—ç‰©ç†æˆ–æ§åˆ¶æ³•åˆ™ï¼Œæ— è®ºå…¶ä¿¡å·å¦‚ä½•å˜åŒ–ï¼Œéƒ½åº”è¯¥èƒ½è¢«åŒä¸€ä¸ªæ•°å­¦æ¨¡å‹å®Œç¾æ‹Ÿåˆï¼›åä¹‹ï¼Œå½“è¿™ä¸ªæ¨¡å‹å¼€å§‹å¤±æ•ˆæ—¶ï¼Œå°±æ„å‘³ç€ç³»ç»Ÿåˆ‡æ¢åˆ°äº†ä¸€ä¸ªæ–°çš„å†…åœ¨æ¨¡å¼ã€‚

*   **å…³é”®æ–¹æ³•**
    ä½œè€…å°†ä¸Šè¿°è§†è§’è½åœ°ä¸ºä¸€ç§ç»Ÿä¸€ã€æ— é˜ˆå€¼çš„æ ¸å¿ƒæœºåˆ¶ï¼š**å°†éçº¿æ€§è‡ªå›å½’æ¨¡å‹ï¼ˆNARXï¼‰çš„æ‹Ÿåˆèƒ½åŠ›ä½œä¸ºâ€œè¯•é‡‘çŸ³â€**ã€‚å…·ä½“è€Œè¨€ï¼Œé€šè¿‡ä¸€ä¸ªæ»‘åŠ¨çª—å£æŒç»­å°è¯•ç”¨å•ä¸€ NARX æ¨¡å‹æ¥æ‹Ÿåˆå±€éƒ¨æ•°æ®æ®µï¼š
    1.  **åˆ†å‰² (Segmentation)ï¼š** å¦‚æœä¸€æ®µæ•°æ®èƒ½è¢«ä¸€ä¸ª NARX æ¨¡å‹å¾ˆå¥½åœ°æ‹Ÿåˆï¼Œåˆ™å®ƒå±äºåŒä¸€ä¸ªæ¨¡å¼ï¼›å½“æ‹Ÿåˆè¯¯å·®é¦–æ¬¡è¶…è¿‡ä¸€ä¸ªæå°çš„ã€æœºå™¨çº§çš„å®¹å¿åº¦æ—¶ï¼Œå³æ ‡å¿—ç€ä¸€ä¸ªæ¨¡å¼åˆ‡æ¢ç‚¹ã€‚
    2.  **èšç±» (Clustering)ï¼š** æ‰€æœ‰èƒ½è¢«*åŒä¸€ä¸ª* NARX æ¨¡å‹å‚æ•°æ‹Ÿåˆçš„æ•°æ®æ®µï¼Œéƒ½è¢«å½’ä¸ºåŒä¸€ç±»ï¼Œå³å¯¹åº”ç³»ç»Ÿçš„åŒä¸€ç§å·¥ä½œæ¨¡å¼ã€‚

*   **æ ¸å¿ƒå‘ç°**
    é€šè¿‡è¿™ç§"ä»¥æ¨¡å‹æ‹Ÿåˆåº¦é‡å†…åœ¨è§„å¾‹"çš„æ–¹æ³•ï¼Œå¯ä»¥åœ¨æ— éœ€ä»»ä½•äººå·¥é˜ˆå€¼çš„æƒ…å†µä¸‹ï¼Œç²¾ç¡®ã€é²æ£’åœ°ä»è§‚æµ‹æ•°æ®ä¸­åæ¨å‡ºé«˜é˜¶ã€éçº¿æ€§æ··åˆç³»ç»Ÿçš„å®Œæ•´ç»“æ„ï¼ˆåŒ…æ‹¬æ¯ç§æ¨¡å¼ä¸‹çš„åŠ¨æ€æ–¹ç¨‹ã€æ¨¡å¼åˆ‡æ¢çš„è¾¹ç•Œæ¡ä»¶ä»¥åŠåˆ‡æ¢æ—¶çš„çŠ¶æ€é‡ç½®è§„åˆ™ï¼‰ï¼Œå…¶ç²¾åº¦å’Œé€‚ç”¨èŒƒå›´å‡æ˜¾è‘—è¶…è¶Šäº†ä¾èµ–å¯¼æ•°çªå˜çš„ä¼ ç»Ÿæ–¹æ³•ã€‚

---

## æŠ€æœ¯å®ç°è¯¦è§£

### 1. NARX æ¨¡å‹çš„æ•°å­¦å½¢å¼

NARX (Nonlinear AutoRegressive with eXogenous inputs) æ¨¡å‹æ˜¯æœ¬æ–¹æ³•çš„æ ¸å¿ƒå·¥å…·ã€‚å¯¹äºç¬¬ i ä¸ªçŠ¶æ€å˜é‡ï¼Œå…¶ NARX æ¨¡å‹å½¢å¼ä¸ºï¼š

```
x_i[t] = Î£(a_j Â· x_i[t-j]) + Î£(b_k Â· u_k[t]) + Î£(c_l Â· Ï†_l(x, u)) + bias
         j=1 to order      k=1 to input_num    l=1 to nonlinear_terms
```

å…¶ä¸­ï¼š
- `x_i[t]` æ˜¯ç¬¬ i ä¸ªçŠ¶æ€å˜é‡åœ¨æ—¶åˆ» t çš„å€¼
- `a_j` æ˜¯è‡ªå›å½’ç³»æ•°ï¼Œæ•æ‰å†å²çŠ¶æ€çš„å½±å“
- `u_k[t]` æ˜¯å¤–éƒ¨è¾“å…¥ä¿¡å·
- `Ï†_l(x, u)` æ˜¯å¯é€‰çš„éçº¿æ€§é¡¹ï¼ˆå¦‚ xâ‚Â·xâ‚‚, sin(xâ‚) ç­‰ï¼‰
- `order` æ˜¯æ¨¡å‹é˜¶æ•°ï¼Œå†³å®šäº†å†å²ä¾èµ–çš„æ—¶é—´æ·±åº¦

**ä»£ç å®ç°** (src/DEConfig.py:147-159)ï¼š
```python
def append_data(self, matrix_list, b_list, data: np.array, input_data):
    """æ„é€  NARX æ¨¡å‹çš„æœ€å°äºŒä¹˜å›å½’çŸ©é˜µ"""
    data = np.array(data)
    input_data = np.array(input_data)
    for i in range(len(data[0]) - self.order):
        # æå–æ»åé¡¹ x[t-1], x[t-2], ..., x[t-order]
        if i == 0:
            this_line = data[:, (self.order - 1)::-1]
            this_line_input = input_data[:, self.order::-1]
        else:
            this_line = data[:, (self.order + i - 1):(i - 1):-1]
            this_line_input = input_data[:, (self.order + i):(i - 1):-1]
        for idx in range(len(this_line)):
            # æ„é€ ç‰¹å¾å‘é‡ [x[t-1], x[t-2], ..., u[t], bias, nonlinear_terms]
            matrix_list[idx].append(self.get_items(this_line, this_line_input, idx))
            b_list[idx].append(data[idx][i + self.order])  # ç›®æ ‡å€¼ x[t]
```

#### 1.1 éçº¿æ€§é¡¹çš„æ·»åŠ è¿‡ç¨‹

å®Œæ•´çš„éçº¿æ€§é¡¹å·¥ä½œæµç¨‹

  æ­¥éª¤1ï¼šåœ¨åˆå§‹åŒ–æ—¶è§£æéçº¿æ€§è¡¨è¾¾å¼
  ```python
class FeatureExtractor:
    def __init__(self, var_num: int, input_num: int, order: int, dt: float,
               need_bias: bool = False, minus: bool = False, other_items: str = ''):
      self.var_num = var_num
      self.order = order
      self.dt = dt
      self.input_num = input_num
      self.minus = minus
      self.need_bias = need_bias
      # â­ å…³é”®ï¼šå°†å­—ç¬¦ä¸²è¡¨è¾¾å¼è½¬æ¢ä¸ºå¯è°ƒç”¨çš„å‡½æ•°
      self.fun_list, self.fun_order = FeatureExtractor.analyticalExpression(
          other_items,  # â† ä¾‹å¦‚: "x[1]*x[2]; x[1]**2; sin(x[1])"
          var_num,
          order
      )
  ```
  æ­¥éª¤2ï¼šanalyticalExpression å°†å­—ç¬¦ä¸²è½¬æ¢ä¸º lambda å‡½æ•°
  ```python
  @staticmethod
  def analyticalExpression(expr_list: str, var_num, order):
      """å°†å­—ç¬¦ä¸²è¡¨è¾¾å¼è§£æä¸ºå¯æ‰§è¡Œçš„ lambda å‡½æ•°"""
      res = [[] for _ in range(var_num)]
      res_order = [[] for _ in range(var_num)]

      expr_list = expr_list.split(';')  # åˆ†å‰²å¤šä¸ªè¡¨è¾¾å¼

      for idx in range(var_num):
          expr = FeatureExtractor.extractValidExpression(expr_list, idx)
          expr = FeatureExtractor.unfoldDigit(expr, order)
          expr = FeatureExtractor.unfoldItem(expr, idx, var_num)

          for s in expr:
              # â­ æ ¸å¿ƒï¼šå°†å­—ç¬¦ä¸²è½¬æ¢ä¸º lambda å‡½æ•°
              res[idx].append(eval('lambda x: ' + s))
              # ä¾‹å¦‚ï¼š"x[0][1]*x[1][1]" â†’ lambda x: x[0][1]*x[1][1]
              res_order[idx].append(FeatureExtractor.findMaxorder(s) + 1)

      return res, res_order
  ```
  æ­¥éª¤3ï¼šget_items è°ƒç”¨è¿™äº› lambda å‡½æ•°
  ```python
  def get_items(self, data, input_data, idx, max_order=None):
      res = []

      # ... æ·»åŠ çº¿æ€§æ»åé¡¹ ...

      # â­ è¿™é‡Œæ‰§è¡Œéçº¿æ€§å‡½æ•°ï¼
      for (fun, order) in zip(self.fun_list[idx], self.fun_order[idx]):
          if order > max_order:
              res.append(0.)
          else:
              res.append(fun(data))  # è°ƒç”¨ lambda å‡½æ•°
              # ä¾‹å¦‚ï¼šfun = lambda x: x[0][1] * x[1][1]
              #      data = [[...], [...], ...]
              #      ç»“æœï¼šdata[0][1] * data[1][1]

      # ... æ·»åŠ è¾“å…¥é¡¹å’Œåç½®é¡¹ ...

      return res
  ```
  å…·ä½“ç¤ºä¾‹è¯´æ˜
  
  å‡è®¾æˆ‘ä»¬è¦ä¸º Duffing æŒ¯å­æ·»åŠ éçº¿æ€§é¡¹ï¼š
```python
  # é…ç½®æ–‡ä»¶ä¸­è®¾ç½®
  config = {
      "order": 3,
      "other_items": "x[1]**3; x[1]*x[2]"  # â† å®šä¹‰éçº¿æ€§é¡¹
  }

  # åˆå§‹åŒ–æ—¶
  get_feature = FeatureExtractor(
      var_num=2,      # ä¸¤ä¸ªçŠ¶æ€å˜é‡ x1, x2
      input_num=1,
      order=3,
      dt=0.01,
      other_items="x[1]**3; x[1]*x[2]"
  )

  # æ­¤æ—¶ self.fun_list åŒ…å«ï¼š
  # fun_list[0] = [lambda x: x[0][0]**3, lambda x: x[0][0]*x[1][0]]
  # fun_list[1] = [lambda x: x[1][0]**3, lambda x: x[1][0]*x[2][0]]
  ```
  åœ¨æ‹Ÿåˆæ—¶ï¼Œå¯¹äºç¬¬ä¸€ä¸ªå˜é‡ï¼ˆidx=0ï¼‰ï¼Œç‰¹å¾å‘é‡æ„æˆä¸ºï¼š
  ```python
  ç‰¹å¾å‘é‡ = [
      x1[t-1],           # çº¿æ€§æ»åé¡¹
      x1[t-2],
      x1[t-3],
      (x1[t-1])Â³,        # â† éçº¿æ€§é¡¹ 1: x[1]**3
      x1[t-1] * x2[t-1], # â† éçº¿æ€§é¡¹ 2: x[1]*x[2]
      u[t],              # è¾“å…¥é¡¹
      1                  # åç½®é¡¹
  ]
  ```
  æœ€ç»ˆçš„ NARX æ¨¡å‹å°±å˜æˆï¼š
  ```python
  x1[t] = a1Â·x1[t-1] + a2Â·x1[t-2] + a3Â·x1[t-3]
          + a4Â·(x1[t-1])Â³           # â† éçº¿æ€§é¡¹
          + a5Â·x1[t-1]Â·x2[t-1]      # â† äº¤å‰éçº¿æ€§é¡¹
          + b1Â·u[t]
          + bias
  ```
  â˜… Insight â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  1. éçº¿æ€§é¡¹çš„å¯æ‰©å±•æ€§ï¼šé€šè¿‡å­—ç¬¦ä¸²è¡¨è¾¾å¼ + eval() çš„è®¾è®¡ï¼Œç”¨æˆ·å¯ä»¥çµæ´»æ·»åŠ ä»»æ„æ•°å­¦è¡¨è¾¾å¼ï¼ˆå¦‚ä¸‰è§’å‡½æ•°ã€æŒ‡æ•°ã€å¤šé¡¹å¼ç­‰ï¼‰ï¼Œè€Œä¸éœ€è¦ä¿®æ”¹æ ¸å¿ƒä»£ç ã€‚
  2. "æƒ°æ€§æ±‚å€¼"è®¾è®¡ï¼šfun_list å­˜å‚¨çš„æ˜¯ lambda å‡½æ•°è€Œä¸æ˜¯å…·ä½“å€¼ï¼Œåªæœ‰åœ¨è°ƒç”¨ get_items() æ—¶æ‰å®é™…è®¡ç®—ï¼Œé¿å…äº†ä¸å¿…è¦çš„å†…å­˜å¼€é”€ã€‚
  3. è¿™ç§è®¾è®¡ä½“ç°äº†è®ºæ–‡çš„æ ¸å¿ƒæ€æƒ³ï¼šNARX æ¨¡å‹ä¸ä»…ä»…æ˜¯çº¿æ€§è‡ªå›å½’ï¼Œé€šè¿‡æ·»åŠ éçº¿æ€§é¡¹ï¼Œå®ƒå¯ä»¥é€¼è¿‘ä»»æ„å¤æ‚çš„éçº¿æ€§åŠ¨åŠ›å­¦ç³»ç»Ÿï¼ˆç±»ä¼¼äºç¥ç»ç½‘ç»œçš„é€šç”¨é€¼è¿‘å®šç†ï¼‰ã€‚
  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  ä»£ç æµç¨‹æ€»ç»“
  ```markdown

  ç”¨æˆ·é…ç½®: other_items = "x[1]**3; sin(x[1])"
      â†“
  [åˆå§‹åŒ–é˜¶æ®µ]
  analyticalExpression() è§£æå­—ç¬¦ä¸²
      â†“
  ç”Ÿæˆ fun_list = [lambda x: x[0][0]**3, lambda x: sin(x[0][0])]
      â†“
  [æ‹Ÿåˆé˜¶æ®µ]
  append_data() æ„é€ å›å½’çŸ©é˜µ
      â†“
      â†“
  get_items() ä¾æ¬¡æ·»åŠ ï¼š
    - çº¿æ€§æ»åé¡¹
    - éçº¿æ€§é¡¹ â† è°ƒç”¨ fun(data)
    - è¾“å…¥é¡¹
    - åç½®é¡¹
      â†“
  è¿”å›å®Œæ•´ç‰¹å¾å‘é‡ç”¨äºæœ€å°äºŒä¹˜æ‹Ÿåˆ
  ```
**æœ€å°äºŒä¹˜æ‹Ÿåˆ** (src/DEConfig.py:124-139)ï¼š
```python
def work_normal(self, data, input_data, is_list: bool):
    """ä½¿ç”¨æœ€å°äºŒä¹˜æ³•æ‹Ÿåˆ NARX æ¨¡å‹"""
    res = []
    err = []
    var_num = len(data) if not is_list else len(data[0])
    matrix_list = [[] for _ in range(var_num)]
    b_list = [[] for _ in range(var_num)]

    # æ„é€ å›å½’çŸ©é˜µ A å’Œç›®æ ‡å‘é‡ b
    if is_list:
        for block, block_input in zip(data, input_data):
            self.append_data(matrix_list, b_list, block, block_input)
    else:
        self.append_data(matrix_list, b_list, data, input_data)

    # å¯¹æ¯ä¸ªå˜é‡æ±‚è§£ min ||Ax - b||Â²
    for a, b in zip(matrix_list, b_list):
        x = np.linalg.lstsq(a, b, rcond=None)[0]  # æœ€å°äºŒä¹˜è§£
        res.append(x)
        err.append(max(np.abs((a @ x) - b)))  # æœ€å¤§æ‹Ÿåˆæ®‹å·®
    return res, err, [self.order for _ in range(self.var_num)]
```

### 2. æœºå™¨çº§å®¹å¿åº¦çš„è®¡ç®—

è¿™æ˜¯"æ— é˜ˆå€¼"æ–¹æ³•çš„å…³é”®â€”â€”ä¸æ˜¯å®Œå…¨æ²¡æœ‰é˜ˆå€¼ï¼Œè€Œæ˜¯ä½¿ç”¨ä¸€ä¸ª**ä¸æ•°æ®å°ºåº¦è‡ªé€‚åº”çš„æå°é˜ˆå€¼**ï¼Œé¿å…äººä¸ºè°ƒå‚ã€‚

**ä»£ç å®ç°** (src/DEConfig.py:77-78)ï¼š
```python
def get_eps(self, data):
    """è®¡ç®—æœºå™¨çº§å®¹å¿åº¦é˜ˆå€¼"""
    return 1e-6 * self.dt * np.max(data)
```

è¿™ä¸ªå…¬å¼çš„è®¾è®¡æ€æƒ³ï¼š
- `1e-6` æ˜¯ä¸€ä¸ªæ¥è¿‘æµ®ç‚¹è¿ç®—ç²¾åº¦çš„æå°å¸¸æ•°
- `dt` æ˜¯é‡‡æ ·æ—¶é—´é—´éš”ï¼Œå°†è¯¯å·®å½’ä¸€åŒ–åˆ°å•ä½æ—¶é—´
- `np.max(data)` ä½¿é˜ˆå€¼ä¸æ•°æ®é‡çº§æˆæ­£æ¯”ï¼Œé€‚åº”ä¸åŒå°ºåº¦çš„ç³»ç»Ÿ

**ä¸¾ä¾‹**ï¼šå¦‚æœæ•°æ®æœ€å¤§å€¼ä¸º 100ï¼Œé‡‡æ ·é—´éš” dt=0.01ï¼Œåˆ™ `eps = 1e-6 * 0.01 * 100 = 1e-6`ï¼Œè¿™æ˜¯ä¸€ä¸ªæå°çš„æ‹Ÿåˆè¯¯å·®è¦æ±‚ã€‚

### 3. æ»‘åŠ¨çª—å£åˆ†å‰²ç®—æ³•

åˆ†å‰²ç®—æ³•é€šè¿‡æ»‘åŠ¨çª—å£æ£€æµ‹æ¨¡å¼åˆ‡æ¢ç‚¹ï¼Œæ ¸å¿ƒæ€æƒ³æ˜¯ï¼š**å½“å•ä¸€ NARX æ¨¡å‹æ— æ³•ç»§ç»­æ‹Ÿåˆæ–°æ•°æ®æ—¶ï¼Œæ ‡è®°ä¸ºåˆ‡æ¢ç‚¹**ã€‚

**ç®—æ³•æµç¨‹** (src/ChangePoints.py:16-49)ï¼š
```python
def find_change_point(data: np.array, input_data: np.array, get_feature, w: int = 10, merge_th=None):
    """
    å‚æ•°ï¼š
        data: çŠ¶æ€å˜é‡æ—¶é—´åºåˆ— (Nå˜é‡ Ã— Mæ—¶é—´ç‚¹)
        input_data: è¾“å…¥ä¿¡å·æ—¶é—´åºåˆ—
        get_feature: NARX æ‹Ÿåˆå‡½æ•°ï¼ˆFeatureExtractor å®ä¾‹ï¼‰
        w: æ»‘åŠ¨çª—å£å¤§å°
        merge_th: åˆå¹¶ç›¸é‚»åˆ‡æ¢ç‚¹çš„é˜ˆå€¼
    """
    change_points = []
    pos = 0
    last = None
    tail_len = 0
    if merge_th is None:
        merge_th = w

    # è®¡ç®—æœºå™¨çº§å®¹å¿åº¦
    eps = get_feature.get_eps(data)

    # æ»‘åŠ¨çª—å£éå†æ—¶é—´åºåˆ—
    while pos + w < data.shape[1]:
        # å¯¹å½“å‰çª—å£æ‹Ÿåˆ NARX æ¨¡å‹
        feature, now_err, fit_order = get_feature(data[:, pos:(pos + w)],
                                                   input_data[:, pos:(pos + w)])

        if last is not None:
            # æ ¸å¿ƒåˆ¤æ–­ï¼šå¦‚æœæ‹Ÿåˆè¯¯å·®è¶…è¿‡å®¹å¿åº¦ï¼Œæ ‡è®°åˆ‡æ¢ç‚¹
            if (max(now_err) > eps) and tail_len == 0:
                change_points.append(pos + w - 1)
                tail_len = w  # é¿å…åœ¨åŒä¸€åŒºåŸŸé‡å¤æ£€æµ‹
            tail_len = max(tail_len - 1, 0)

        last = fit_order
        pos += 1  # çª—å£æ¯æ¬¡æ»‘åŠ¨ 1 ä¸ªæ—¶é—´æ­¥

    # åˆå¹¶è¿‡äºæ¥è¿‘çš„åˆ‡æ¢ç‚¹
    res = mergeChangePoints(change_points, merge_th)
    res.append(data.shape[1])
    res.insert(0, 0)
    return res
```

#### 3.1 æ»‘åŠ¨çª—å£å·¥ä½œæœºåˆ¶è¯¦è§£

**æ¯ä¸ªçª—å£ç‹¬ç«‹æ‹Ÿåˆ**ï¼š
```python
feature, now_err, fit_order = get_feature(data[:, pos:(pos + w)], input_data[:, pos:(pos + w)])
```

è¿™ä¸€è¡Œä»£ç åœ¨æ¯æ¬¡å¾ªç¯ä¸­æ‰§è¡Œä»¥ä¸‹æ“ä½œï¼š

1. **æå–çª—å£æ•°æ®**ï¼š`data[:, pos:(pos + w)]` æå–é•¿åº¦ä¸º `w` çš„æ—¶é—´çª—å£
2. **æ„é€ å›å½’çŸ©é˜µ**ï¼šé€šè¿‡ `append_data()` æ„é€  NARX ç‰¹å¾çŸ©é˜µ `A` å’Œç›®æ ‡å‘é‡ `b`
3. **æœ€å°äºŒä¹˜æ‹Ÿåˆ**ï¼šæ±‚è§£ `min ||Ax - b||Â²` å¾—åˆ°æ¨¡å‹å‚æ•° `x`
4. **è®¡ç®—æ‹Ÿåˆè¯¯å·®**ï¼š`now_err = max(|Ax - b|)`ï¼Œå³é¢„æµ‹å€¼ä¸çœŸå®å€¼çš„æœ€å¤§æ®‹å·®

**æ»‘åŠ¨è¿‡ç¨‹ç¤ºä¾‹**ï¼ˆå‡è®¾ `w=10`ï¼Œæ€»æ—¶é—´ç‚¹ `M=100`ï¼‰ï¼š
```
è¿­ä»£ 1:  pos=0   â†’ æ‹Ÿåˆ data[0:10]   â†’ errâ‚
è¿­ä»£ 2:  pos=1   â†’ æ‹Ÿåˆ data[1:11]   â†’ errâ‚‚
è¿­ä»£ 3:  pos=2   â†’ æ‹Ÿåˆ data[2:12]   â†’ errâ‚ƒ
...
è¿­ä»£ 90: pos=89  â†’ æ‹Ÿåˆ data[89:99]  â†’ errâ‚‰â‚€
è¿­ä»£ 91: pos=90  â†’ æ‹Ÿåˆ data[90:100] â†’ errâ‚‰â‚  (æœ€åä¸€ä¸ªçª—å£)

æ€»æ‹Ÿåˆæ¬¡æ•°: M - w = 90 æ¬¡
```

#### 3.2 ä¸ºä»€ä¹ˆå‚æ•°é‡æ‹Ÿåˆä¸ä¼šæ©ç›–å˜ç‚¹ï¼Ÿ

**å…³é”®æ´å¯Ÿ**ï¼šè™½ç„¶æ¯ä¸ªçª—å£éƒ½é‡æ–°ä¼˜åŒ–å‚æ•°ï¼Œä½†å½“çª—å£è·¨è¶Šå˜ç‚¹æ—¶ï¼Œå•ä¸€ NARX æ¨¡å‹é¢ä¸´"ä¸å¯èƒ½å®Œæˆçš„ä»»åŠ¡"ã€‚

**åœºæ™¯ç¤ºä¾‹ï¼šå¼¹è·³çƒç³»ç»Ÿ**
```
æ—¶é—´ç‚¹:  0  1  2  3  4  5  6  7  8  9  10 11 12 13 14 15
æ¨¡æ€:    [------- æ¨¡æ€1: è‡ªç”±è½ä½“ -------][å˜ç‚¹][--- æ¨¡æ€2: é™æ­¢ ---]
é€Ÿåº¦:    -1 -2 -3 -4 -5 -6 -7 -8 -9 -10   0  0  0  0  0  0
åŠ¨åŠ›å­¦:  v[t+1] = v[t] - gÂ·dt              v[t+1] = 0
```

**çª—å£1 [0:10]ï¼ˆçº¯æ¨¡æ€1ï¼‰**ï¼š
```
æ•°æ®: v = [-1, -2, -3, -4, -5, -6, -7, -8, -9, -10]
æ‹Ÿåˆ: v[t+1] = aÂ·v[t] + b  â†’  aâ‰ˆ1.0, bâ‰ˆ-1.0
æ®‹å·®: |Ax - b| â‰ˆ 1e-10  (å®Œç¾æ‹Ÿåˆ)
ç»“è®º: err < eps âœ“  æ— å˜ç‚¹
```

**çª—å£2 [5:15]ï¼ˆè·¨è¶Šå˜ç‚¹ï¼ï¼‰**ï¼š
```
æ•°æ®: v = [-5, -6, -7, -8, -9, -10, 0, 0, 0, 0]
                                    â†‘ å˜ç‚¹åœ¨è¿™é‡Œ
å°è¯•æ‹Ÿåˆå•ä¸€æ¨¡å‹ v[t+1] = aÂ·v[t] + b:
  - å‰åŠéƒ¨åˆ†éœ€è¦: aâ‰ˆ1, bâ‰ˆ-1  (ä¸‹è½è§„å¾‹)
  - ååŠéƒ¨åˆ†éœ€è¦: aâ‰ˆ0, bâ‰ˆ0   (é™æ­¢è§„å¾‹)
  â†’ æœ€å°äºŒä¹˜æ‰¾åˆ°æŠ˜ä¸­è§£: aâ‰ˆ0.5, bâ‰ˆ-0.5
  â†’ å‰åŠéƒ¨åˆ†æ®‹å·®: |-6 - (0.5Ã—(-5) - 0.5)| = |-6 - (-3)| = 3
  â†’ ååŠéƒ¨åˆ†æ®‹å·®: |0 - (0.5Ã—0 - 0.5)| = 0.5
æ®‹å·®: max(|Ax - b|) â‰ˆ 3.0  (æ˜¾è‘—å¢å¤§ï¼)
ç»“è®º: err >> eps âœ—  æ£€æµ‹åˆ°å˜ç‚¹
```

**çª—å£3 [10:20]ï¼ˆçº¯æ¨¡æ€2ï¼‰**ï¼š
```
æ•°æ®: v = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
æ‹Ÿåˆ: v[t+1] = 0  (å¸¸æ•°æ¨¡å‹)
æ®‹å·®: â‰ˆ 1e-10  (å®Œç¾æ‹Ÿåˆ)
ç»“è®º: err < eps âœ“  æ— å˜ç‚¹
```

**æ•°å­¦è§£é‡Š**ï¼š
å½“çª—å£åŒ…å« `nâ‚` ä¸ªæ¨¡æ€1æ•°æ®å’Œ `nâ‚‚` ä¸ªæ¨¡æ€2æ•°æ®æ—¶ï¼Œä¼˜åŒ–é—®é¢˜ä¸ºï¼š

$$
\min_{\theta} \left[ \sum_{i=1}^{n_1} (y_i^{(1)} - f_\theta(x_i))^2 + \sum_{j=1}^{n_2} (y_j^{(2)} - f_\theta(x_j))^2 \right]
$$

- å•ä¸€å‚æ•° $\theta$ å¿…é¡»åŒæ—¶æ‹Ÿåˆä¸¤ä¸ªä¸åŒçš„åŠ¨åŠ›å­¦ç³»ç»Ÿ
- è¿™å¯¼è‡´ä¸¤ä¸ªç›®æ ‡ç›¸äº’å†²çªï¼Œæœ€å°äºŒä¹˜è§£æ˜¯ä¸€ä¸ªæŠ˜ä¸­å€¼
- æŠ˜ä¸­è§£åœ¨ä¸¤ä¸ªæ¨¡æ€ä¸Šçš„æ‹Ÿåˆè´¨é‡éƒ½ä¼šä¸‹é™ï¼Œæ®‹å·®æ˜¾è‘—å¢å¤§

**å…³é”®è®¾è®¡**ï¼š
- **tail_len æœºåˆ¶**ï¼šæ£€æµ‹åˆ°åˆ‡æ¢ç‚¹åï¼Œè·³è¿‡åç»­ `w` ä¸ªä½ç½®ï¼Œé¿å…åœ¨åŒä¸€åˆ‡æ¢è¾¹ç•Œé‡å¤æ ‡è®°
- **mergeChangePoints**ï¼šå¦‚æœä¸¤ä¸ªåˆ‡æ¢ç‚¹é—´éš”å°äº `merge_th`ï¼Œåªä¿ç•™ç¬¬ä¸€ä¸ªï¼Œæ¶ˆé™¤å™ªå£°å¯¼è‡´çš„è™šå‡æ£€æµ‹
- **è‡ªé€‚åº”é˜ˆå€¼ eps**ï¼š`1e-6 * dt * max(data)` ç¡®ä¿é˜ˆå€¼ä¸æ•°æ®å°ºåº¦æˆæ­£æ¯”ï¼Œçº¯æ¨¡æ€çª—å£çš„è¯¯å·®é€šå¸¸è¿œå°äº `eps`ï¼ˆçº¦ `1e-10`ï¼‰ï¼Œè€Œè·¨æ¨¡æ€çª—å£è¯¯å·®å¯è¾¾ `1e-3` ä»¥ä¸Š

**å¯è§†åŒ–ç†è§£**ï¼š
```
æ—¶é—´åºåˆ—: |====æ¨¡å¼A====|****|====æ¨¡å¼B====|****|====æ¨¡å¼C====|
çª—å£ä½ç½®:  [----w----]                              â† pos=0,  errâ‰ˆ1e-10
            [----w----]                             â† pos=1,  errâ‰ˆ1e-10
                [----w----]                         â† pos=5,  errâ‰ˆ1e-10
                    [----w----]                     â† pos=10, errâ‰ˆ1e-3 âœ— å˜ç‚¹!
                        [----w----]                 â† pos=15, errâ‰ˆ1e-10
                              [----w----]           â† pos=20, errâ‰ˆ1e-10
                                    [----w----]     â† pos=30, errâ‰ˆ1e-3 âœ— å˜ç‚¹!

æ£€æµ‹é€»è¾‘: max(now_err) > eps  â†’  æ ‡è®°å˜ç‚¹
```

#### 3.3 è®¡ç®—å¤æ‚åº¦ä¸æ•ˆç‡

- **æ€»æ—¶é—´ç‚¹æ•°**ï¼š`M`
- **çª—å£å¤§å°**ï¼š`w` (å…¸å‹å€¼ 10-20)
- **æ‹Ÿåˆæ¬¡æ•°**ï¼š`M - w` æ¬¡ï¼ˆçº¿æ€§å¤æ‚åº¦ï¼‰
- **æ¯æ¬¡æ‹Ÿåˆå¤æ‚åº¦**ï¼š`O(w Â· dÂ²)`ï¼Œå…¶ä¸­ `d` æ˜¯ç‰¹å¾ç»´åº¦ï¼ˆorder + éçº¿æ€§é¡¹æ•°é‡ï¼‰
- **æ€»å¤æ‚åº¦**ï¼š`O(M Â· w Â· dÂ²)` â€” å¯¹äºå®é™…è§„æ¨¡çš„æ•°æ®ï¼ˆM~1000, w~10, d~10ï¼‰ä»ç„¶é«˜æ•ˆ

### 4. åŠ¨æ€é˜ˆå€¼æ ¡å‡†

è™½ç„¶åˆ†å‰²é˜¶æ®µä½¿ç”¨äº†æœºå™¨çº§é˜ˆå€¼ï¼Œä½†åœ¨èšç±»é˜¶æ®µéœ€è¦ä¸€ä¸ªæ›´å®½æ¾çš„é˜ˆå€¼ï¼Œç”¨äºåˆ¤æ–­"ä¸¤ä¸ªæ•°æ®æ®µæ˜¯å¦å±äºåŒä¸€æ¨¡å¼"ã€‚è¿™ä¸ªé˜ˆå€¼é€šè¿‡**è®­ç»ƒæ•°æ®è‡ªåŠ¨æ ¡å‡†**ï¼Œé¿å…äº†äººå·¥è°ƒå‚çš„å›°æ‰°ã€‚

#### 4.1 ä¸ºä»€ä¹ˆéœ€è¦åŠ¨æ€é˜ˆå€¼æ ¡å‡†ï¼Ÿ

åœ¨å®Œæˆæ•°æ®åˆ†å‰²åï¼Œæ‰€æœ‰è½¨è¿¹çš„ç‰‡æ®µï¼ˆsegmentsï¼‰éƒ½è¢«ä¿å­˜åœ¨ `slice_data` åˆ—è¡¨ä¸­ã€‚è¿™äº›ç‰‡æ®µéœ€è¦è¢«è¿›ä¸€æ­¥èšç±»ä»¥è¯†åˆ«ä¸åŒçš„åŠ¨æ€æ¨¡å¼ã€‚å…³é”®é—®é¢˜æ˜¯ï¼š**å¦‚ä½•åˆ¤æ–­ä¸¤ä¸ªç‰‡æ®µæ˜¯å¦å±äºåŒä¸€æ¨¡å¼ï¼Ÿ**

ä¼ ç»Ÿæ–¹æ³•é€šè¿‡æ¯”è¾ƒå‚æ•°å‘é‡çš„æ¬§æ°è·ç¦»(DTW)æ¥åˆ¤æ–­ï¼Œä½†è¿™ç§æ–¹æ³•å­˜åœ¨è‡´å‘½ç¼ºé™·ï¼š
- **é˜ˆå€¼çš„äººå·¥è®¾å®š**ï¼šè·ç¦»é˜ˆå€¼éœ€è¦æ‰‹åŠ¨è°ƒæ•´ï¼Œç¼ºä¹ç‰©ç†æ„ä¹‰
- **å°ºåº¦æ•æ„Ÿæ€§**ï¼šä¸åŒç³»ç»Ÿçš„å‚æ•°é‡çº§å·®å¼‚å·¨å¤§ï¼Œå›ºå®šé˜ˆå€¼æ— æ³•é€‚åº”
- **å™ªå£°æ•æ„Ÿæ€§**ï¼šå‚æ•°æ‰°åŠ¨å¯èƒ½å¯¼è‡´è·ç¦»è¶…è¿‡é˜ˆå€¼ï¼Œè¯¯åˆ¤ä¸ºä¸åŒæ¨¡å¼

æœ¬æ–¹æ³•é‡‡ç”¨**æ•°æ®é©±åŠ¨çš„è‡ªé€‚åº”é˜ˆå€¼å­¦ä¹ **ï¼Œä»è®­ç»ƒæ•°æ®æœ¬èº«æ¨æ–­å‡ºåˆç†çš„é˜ˆå€¼èŒƒå›´ã€‚

#### 4.2 é˜ˆå€¼æ ¡å‡†çš„æ ¸å¿ƒæ€æƒ³

**åŸºæœ¬å‡è®¾**ï¼šåœ¨æ—¶é—´åºåˆ—ä¸­ï¼Œç›¸é‚»ç‰‡æ®µé€šå¸¸æ¥è‡ªä¸åŒæ¨¡å¼ï¼ˆå› ä¸ºå®ƒä»¬ç”±å˜åŒ–ç‚¹åˆ†å‰²ï¼‰ã€‚å› æ­¤ï¼Œ**ç›¸é‚»ç‰‡æ®µä¹‹é—´çš„æ‹Ÿåˆè¯¯å·®å¯ä»¥ä½œä¸º"æ¨¡å¼é—´æœ€å°å·®å¼‚"çš„ä¼°è®¡**ã€‚

**æ ¡å‡†ç­–ç•¥**ï¼š
1. éå†æ‰€æœ‰ç›¸é‚»ç‰‡æ®µå¯¹ `(slice[i], slice[i+1])`
2. å°è¯•ç”¨å•ä¸€ NARX æ¨¡å‹åŒæ—¶æ‹Ÿåˆè¿™ä¸¤ä¸ªç‰‡æ®µ
3. è®°å½•æ‹Ÿåˆè¯¯å·® `err` å’Œå‚æ•°å·®å¼‚ `dis`
4. å°†é˜ˆå€¼è®¾ä¸ºæ‰€æœ‰è¯¯å·®çš„ **10%**ï¼ˆ`ToleranceRatio = 0.1`ï¼‰

è¿™æ ·è®¾å®šçš„é˜ˆå€¼æ—¢èƒ½åŒºåˆ†ä¸åŒæ¨¡å¼ï¼ˆè¯¯å·®è¿œå¤§äºé˜ˆå€¼ï¼‰ï¼Œåˆèƒ½å®¹å¿åŒä¸€æ¨¡å¼å†…çš„å°å¹…æ³¢åŠ¨ï¼ˆè¯¯å·®è¿œå°äºé˜ˆå€¼ï¼‰ã€‚

#### 4.3 ä»£ç å®ç°æµç¨‹

**ä¸»æµç¨‹**ï¼ˆmain.py:40-46ï¼‰ï¼š
```python
# ç¬¬1æ­¥ï¼šåˆ‡åˆ†æ‰€æœ‰è½¨è¿¹ï¼Œå¾—åˆ°ç‰‡æ®µåˆ—è¡¨
slice_data = []
for data, input_val in zip(data_list, input_data):
    change_points = find_change_point(data, input_val, get_feature, w=config['window_size'])
    slice_curve(slice_data, data, input_val, change_points, get_feature)
    # â†‘ slice_curve å°†æ¯æ¡è½¨è¿¹æŒ‰å˜åŒ–ç‚¹åˆ‡åˆ†ï¼Œå¹¶æŠŠæ‰€æœ‰ç‰‡æ®µç´¯ç§¯åˆ° slice_data ä¸­

# ç¬¬2æ­¥ï¼šè®¾ç½®èšç±»æ–¹æ³•
Slice.Method = config['clustering_method']  # 'fit' æˆ– 'dis'

# ç¬¬3æ­¥ï¼šåŠ¨æ€æ ¡å‡†é˜ˆå€¼ â† æ ¸å¿ƒæ­¥éª¤
Slice.fit_threshold(slice_data)

# ç¬¬4æ­¥ï¼šä½¿ç”¨æ ¡å‡†çš„é˜ˆå€¼è¿›è¡Œèšç±»
clustering(slice_data, config['self_loop'])
```

**é˜ˆå€¼æ ¡å‡†å‡½æ•°**ï¼ˆsrc/CurveSlice.py:56-63ï¼‰ï¼š
```python
@staticmethod
def fit_threshold(data: list):
    """éå†æ‰€æœ‰ç‰‡æ®µï¼Œæ ¡å‡†ä¸‰ç§ç±»å‹çš„é˜ˆå€¼"""
    # æ¯”è¾ƒç›¸é‚»ç‰‡æ®µï¼ˆè·³è¿‡æ¯æ¡è½¨è¿¹çš„é¦–ç‰‡æ®µï¼‰
    for i in range(len(data)):
        if data[i].isFront:  # å¦‚æœæ˜¯æŸæ¡è½¨è¿¹çš„ç¬¬ä¸€ä¸ªç‰‡æ®µï¼Œè·³è¿‡
            continue
        # å°†å½“å‰ç‰‡æ®µä¸å‰ä¸€ä¸ªç‰‡æ®µæ¯”è¾ƒï¼Œæ›´æ–°å…¨å±€é˜ˆå€¼
        Slice.fit_threshold_one(data[i].get_feature, data[i], data[i - 1])
    
    # éªŒè¯æ‰€æœ‰ç‰‡æ®µçš„æœ‰æ•ˆæ€§ï¼ˆæ ‡è®°æ‹Ÿåˆè¯¯å·®è¿‡å¤§çš„ç‰‡æ®µï¼‰
    for s in data:
        s.check_valid()
```

**å•å¯¹ç‰‡æ®µçš„é˜ˆå€¼æ ¡å‡†**ï¼ˆsrc/CurveSlice.py:32-54ï¼‰ï¼š
```python
@staticmethod
def fit_threshold_one(get_feature, data1, data2):
    """æ¯”è¾ƒä¸¤ä¸ªç›¸é‚»æ•°æ®æ®µï¼Œæ ¡å‡†ä¸‰ç§é˜ˆå€¼"""
    feature1 = data1.feature  # data1 çš„ NARX å‚æ•°
    feature2 = data2.feature  # data2 çš„ NARX å‚æ•°
    
    # 1ï¸âƒ£ æ‹Ÿåˆè¯¯å·®é˜ˆå€¼ï¼ˆFitErrorThresholdï¼‰
    # å°è¯•ç”¨å•ä¸€ NARX æ¨¡å‹åŒæ—¶æ‹Ÿåˆè¿™ä¸¤ä¸ªæ•°æ®æ®µ
    _, err, fit_order = get_feature([data1.data, data2.data],
                                  [data1.input_data, data2.input_data], is_list=True)
    
    # å¦‚æœæ‹Ÿåˆé˜¶æ•°æ²¡æœ‰å¢åŠ ï¼Œè¯´æ˜ä¸¤æ®µå¯èƒ½å±äºä¸åŒæ¨¡å¼ä½†åŠ¨æ€å¤æ‚åº¦ç›¸è¿‘
    if fit_order <= max(data1.fit_order, data2.fit_order):
        # æ›´æ–°é˜ˆå€¼ä¸ºå½“å‰è¯¯å·®çš„ 10%ï¼ˆå–æ‰€æœ‰è¯¯å·®çš„æœ€å°å€¼ï¼‰
        Slice.FitErrorThreshold = min(Slice.FitErrorThreshold,
                                      max(err) * Slice.ToleranceRatio)
        Slice.FitErrorThreshold = max(Slice.FitErrorThreshold, 1e-6)  # ä¸‹é™ä¿æŠ¤

    # åˆå§‹åŒ–é˜ˆå€¼åˆ—è¡¨ï¼ˆé•¿åº¦ä¸ç‰¹å¾å‘é‡ç»´åº¦ä¸€è‡´ï¼‰
    while len(Slice.RelativeErrorThreshold) < len(feature1):
        Slice.RelativeErrorThreshold.append(1e-1)
        Slice.AbsoluteErrorThreshold.append(1e-1)
    
    # 2ï¸âƒ£ å‚æ•°è·ç¦»é˜ˆå€¼ï¼ˆç”¨äº 'dis' èšç±»æ–¹æ³•ï¼‰
    idx = 0
    for v1, v2 in zip(feature1, feature2):
        relative_dis, dis = Slice.get_dis(v1, v2)
        # ç›¸å¯¹è·ç¦»é˜ˆå€¼ï¼šé€‚ç”¨äºå¤§æ•°å€¼å‚æ•°
        if relative_dis > 1e-4:
            Slice.RelativeErrorThreshold[idx] = \
                min(Slice.RelativeErrorThreshold[idx], relative_dis * Slice.ToleranceRatio)
        # ç»å¯¹è·ç¦»é˜ˆå€¼ï¼šé€‚ç”¨äºå°æ•°å€¼å‚æ•°
        if dis > 1e-4:
            Slice.AbsoluteErrorThreshold[idx] = \
                min(Slice.AbsoluteErrorThreshold[idx], max(dis * Slice.ToleranceRatio, 1e-6))
        idx += 1
    return True
```

**è·ç¦»è®¡ç®—å‡½æ•°**ï¼ˆsrc/CurveSlice.py:23-29ï¼‰ï¼š
```python
@staticmethod
def get_dis(v1, v2):
    """è®¡ç®—ä¸¤ä¸ªå‚æ•°å‘é‡çš„ç›¸å¯¹è·ç¦»å’Œç»å¯¹è·ç¦»"""
    dis = np.linalg.norm(v1 - v2, ord=1)  # L1 è·ç¦»ï¼ˆç»å¯¹è·ç¦»ï¼‰
    d1 = np.linalg.norm(v1, ord=1)
    d2 = np.linalg.norm(v2, ord=1)
    d_min = min(d1, d2)
    relative_dis = dis / max(d_min, 1e-6)  # ç›¸å¯¹è·ç¦» = å·®å€¼ / æœ€å°å€¼
    return relative_dis, dis
```

**ç‰‡æ®µæœ‰æ•ˆæ€§æ£€æŸ¥**ï¼ˆsrc/CurveSlice.py:65-68ï¼‰ï¼š
```python
def check_valid(self):
    """æ£€æŸ¥ç‰‡æ®µçš„æ‹Ÿåˆè¯¯å·®æ˜¯å¦è¶…è¿‡é˜ˆå€¼"""
    if self.valid and self.err > Slice.FitErrorThreshold:
        warnings.warn("Find a invalid segmentation!")
        self.valid = False  # æ ‡è®°ä¸ºæ— æ•ˆç‰‡æ®µï¼Œåç»­èšç±»æ—¶è·³è¿‡
```

#### 4.4 ä¸‰ç§é˜ˆå€¼çš„ä½œç”¨

| é˜ˆå€¼ç±»å‹ | å˜é‡å | ç”¨é€” | è®¡ç®—æ–¹å¼ |
|---------|--------|------|---------|
| **æ‹Ÿåˆè¯¯å·®é˜ˆå€¼** | `FitErrorThreshold` | åˆ¤æ–­å¤šä¸ªç‰‡æ®µèƒ½å¦è¢«å•ä¸€ NARX æ¨¡å‹æ‹Ÿåˆ | `min(ç›¸é‚»æ®µè”åˆæ‹Ÿåˆè¯¯å·®) Ã— 0.1` |
| **ç›¸å¯¹è·ç¦»é˜ˆå€¼** | `RelativeErrorThreshold` | åˆ¤æ–­å‚æ•°å‘é‡çš„ç›¸å¯¹å·®å¼‚ï¼ˆé€‚ç”¨å¤§æ•°å€¼ï¼‰ | `min(ç›¸é‚»æ®µå‚æ•°ç›¸å¯¹è·ç¦») Ã— 0.1` |
| **ç»å¯¹è·ç¦»é˜ˆå€¼** | `AbsoluteErrorThreshold` | åˆ¤æ–­å‚æ•°å‘é‡çš„ç»å¯¹å·®å¼‚ï¼ˆé€‚ç”¨å°æ•°å€¼ï¼‰ | `min(ç›¸é‚»æ®µå‚æ•°ç»å¯¹è·ç¦») Ã— 0.1` |

**é˜ˆå€¼é€‰æ‹©ç­–ç•¥**ï¼š
- é»˜è®¤ä½¿ç”¨ **æ‹Ÿåˆè¯¯å·®é˜ˆå€¼**ï¼ˆ`clustering_method = 'fit'`ï¼‰ï¼ŒåŸºäºç‰©ç†æ„ä¹‰ï¼Œæ›´é²æ£’
- å¯é€‰ä½¿ç”¨ **è·ç¦»é˜ˆå€¼**ï¼ˆ`clustering_method = 'dis'`ï¼‰ï¼Œè®¡ç®—æ›´å¿«ä½†å¯¹å™ªå£°æ•æ„Ÿ

#### 4.5 å·¥ä½œæœºåˆ¶ç¤ºä¾‹

å‡è®¾æœ‰ä¸€æ¡è½¨è¿¹è¢«åˆ†å‰²æˆ 5 ä¸ªç‰‡æ®µï¼š

```
ç‰‡æ®µåºåˆ—ï¼š  [æ®µ0]  [æ®µ1]  [æ®µ2]  [æ®µ3]  [æ®µ4]
æ¨¡å¼å½’å±ï¼š   A      B      A      C      A
```

**æ ¡å‡†è¿‡ç¨‹**ï¼š
```
æ¯”è¾ƒå¯¹1ï¼šæ®µ0 vs æ®µ1ï¼ˆæ¨¡å¼A vs Bï¼‰
  â†’ è”åˆæ‹Ÿåˆè¯¯å·® errâ‚ = 0.05
  â†’ FitErrorThreshold = min(1.0, 0.05 Ã— 0.1) = 0.005

æ¯”è¾ƒå¯¹2ï¼šæ®µ1 vs æ®µ2ï¼ˆæ¨¡å¼B vs Aï¼‰
  â†’ è”åˆæ‹Ÿåˆè¯¯å·® errâ‚‚ = 0.08
  â†’ FitErrorThreshold = min(0.005, 0.08 Ã— 0.1) = 0.005

æ¯”è¾ƒå¯¹3ï¼šæ®µ2 vs æ®µ3ï¼ˆæ¨¡å¼A vs Cï¼‰
  â†’ è”åˆæ‹Ÿåˆè¯¯å·® errâ‚ƒ = 0.12
  â†’ FitErrorThreshold = min(0.005, 0.12 Ã— 0.1) = 0.005

æ¯”è¾ƒå¯¹4ï¼šæ®µ3 vs æ®µ4ï¼ˆæ¨¡å¼C vs Aï¼‰
  â†’ è”åˆæ‹Ÿåˆè¯¯å·® errâ‚„ = 0.10
  â†’ FitErrorThreshold = min(0.005, 0.10 Ã— 0.1) = 0.005

æœ€ç»ˆé˜ˆå€¼ï¼šFitErrorThreshold = 0.005
```

**åç»­èšç±»æ—¶çš„åˆ¤æ–­**ï¼š
- åŒä¸€æ¨¡å¼å†…çš„ç‰‡æ®µï¼ˆå¦‚æ®µ0å’Œæ®µ2ï¼‰ï¼šæ‹Ÿåˆè¯¯å·® â‰ˆ 1e-10 << 0.005 âœ“ å½’ä¸ºåŒç±»
- ä¸åŒæ¨¡å¼çš„ç‰‡æ®µï¼ˆå¦‚æ®µ0å’Œæ®µ1ï¼‰ï¼šæ‹Ÿåˆè¯¯å·® â‰ˆ 0.05 >> 0.005 âœ— å½’ä¸ºä¸åŒç±»

#### 4.6 è®¾è®¡ä¼˜åŠ¿

1. **è‡ªé€‚åº”æ€§**ï¼šé˜ˆå€¼ä»æ•°æ®æœ¬èº«å­¦ä¹ ï¼Œæ— éœ€äººå·¥è°ƒå‚
2. **å°ºåº¦ä¸å˜æ€§**ï¼šé€šè¿‡ç›¸å¯¹è·ç¦»å’Œè¯¯å·®ç™¾åˆ†æ¯”ï¼Œé€‚åº”ä¸åŒé‡çº§çš„ç³»ç»Ÿ
3. **ç‰©ç†å¯è§£é‡Šæ€§**ï¼šé˜ˆå€¼ä»£è¡¨"æ¨¡å¼é—´æœ€å°å·®å¼‚çš„ 10%"ï¼Œæœ‰æ˜ç¡®çš„ç»Ÿè®¡æ„ä¹‰
4. **é²æ£’æ€§**ï¼šé€šè¿‡ `min()` æ“ä½œé€‰æ‹©æœ€ä¸¥æ ¼çš„é˜ˆå€¼ï¼Œé™ä½è¯¯åˆ†ç±»é£é™©
5. **å®¹é”™æ€§**ï¼š10% çš„å®¹å¿æ¯”ä¾‹å…è®¸å™ªå£°å’Œå°å¹…æ³¢åŠ¨

**å…³é”®æ´å¯Ÿ**ï¼š
> é˜ˆå€¼æ ¡å‡†çš„æœ¬è´¨æ˜¯ä¸€ç§**"å¯¹æ¯”å­¦ä¹ "**â€”â€”é€šè¿‡æ¯”è¾ƒç¡®å®šå±äºä¸åŒæ¨¡å¼çš„ç‰‡æ®µå¯¹ï¼Œå­¦ä¹ "ä»€ä¹ˆæ˜¯ä¸åŒ"çš„æ ‡å‡†ï¼Œç„¶åå°†è¿™ä¸ªæ ‡å‡†ç¼©å° 10 å€ä½œä¸ºèšç±»çš„è¾¹ç•Œã€‚è¿™ç§æ–¹æ³•å·§å¦™åœ°å°†"æ— ç›‘ç£èšç±»"é—®é¢˜è½¬åŒ–ä¸º"å¼±ç›‘ç£å­¦ä¹ "é—®é¢˜ï¼ˆæ—¶åºä¿¡æ¯æä¾›äº†å¼±æ ‡ç­¾ï¼‰ã€‚

#### 4.7 ä¸åˆ†å‰²é˜¶æ®µé˜ˆå€¼çš„å¯¹æ¯”

| ç‰¹æ€§ | åˆ†å‰²é˜¶æ®µï¼ˆæœºå™¨çº§é˜ˆå€¼ï¼‰ | èšç±»é˜¶æ®µï¼ˆåŠ¨æ€é˜ˆå€¼ï¼‰ |
|------|----------------------|---------------------|
| **ç›®çš„** | æ£€æµ‹æ¨¡å¼åˆ‡æ¢çš„ç²¾ç¡®æ—¶åˆ» | åˆ¤æ–­ç‰‡æ®µæ˜¯å¦å±äºåŒä¸€æ¨¡å¼ |
| **é˜ˆå€¼æ¥æº** | æ•°å­¦å®šä¹‰ `1e-6 Ã— dt Ã— max(data)` | æ•°æ®é©±åŠ¨å­¦ä¹  |
| **ä¸¥æ ¼ç¨‹åº¦** | æä¸¥æ ¼ï¼ˆè¯¯å·® ~1e-10 æ‰é€šè¿‡ï¼‰ | ç›¸å¯¹å®½æ¾ï¼ˆè¯¯å·® < 0.005 å¯é€šè¿‡ï¼‰ |
| **ç‰©ç†æ„ä¹‰** | å•ä¸€æ¨¡å‹å®Œç¾æ‹Ÿåˆçš„æé™ | æ¨¡å¼é—´å·®å¼‚çš„å®¹å¿è¾¹ç•Œ |

**æµç¨‹ç¤ºæ„**ï¼š
```
åŸå§‹æ•°æ®
   â†“
[åˆ†å‰²é˜¶æ®µ] ä½¿ç”¨æœºå™¨çº§é˜ˆå€¼ï¼ˆä¸¥æ ¼ï¼‰
   â†“ æ£€æµ‹åˆ°å˜åŒ–ç‚¹
åˆ‡åˆ†åçš„ç‰‡æ®µåˆ—è¡¨ (slice_data)
   â†“
[æ ¡å‡†é˜¶æ®µ] å­¦ä¹ åŠ¨æ€é˜ˆå€¼ï¼ˆè‡ªé€‚åº”ï¼‰ â† æœ¬èŠ‚é‡ç‚¹
   â†“ è®¡ç®— FitErrorThreshold
[èšç±»é˜¶æ®µ] ä½¿ç”¨åŠ¨æ€é˜ˆå€¼ï¼ˆå®½æ¾ï¼‰
   â†“
æ¨¡å¼è¯†åˆ«ç»“æœ
```

### 5. åŸºäºæ‹Ÿåˆèƒ½åŠ›çš„èšç±»ç®—æ³•

è¿™æ˜¯æ–¹æ³•çš„æ ¸å¿ƒåˆ›æ–°ï¼š**ä¸æ˜¯æ¯”è¾ƒå‚æ•°å‘é‡çš„è·ç¦»ï¼Œè€Œæ˜¯æµ‹è¯•"èƒ½å¦ç”¨åŒä¸€ç»„ NARX å‚æ•°æ‹Ÿåˆä¸åŒæ•°æ®æ®µ"**ã€‚èšç±»ç®—æ³•å®ç°äº†è®ºæ–‡ä¸­çš„**å¯åˆå¹¶æ€§ï¼ˆMergeableï¼‰**å’Œ**æœ€å°å¯åˆå¹¶æ€§ï¼ˆMinimally Mergeableï¼‰**æ¦‚å¿µã€‚

> ğŸ’¡ **è¯¦ç»†åˆ†ææ–‡æ¡£**ï¼šå®Œæ•´çš„èšç±»ç®—æ³•åˆ†æè¯·å‚è§ [clustering_detailed_analysis.md](./clustering_detailed_analysis.md)ï¼ŒåŒ…å«ç†è®ºåŸºç¡€ã€ç®—æ³•æµç¨‹ã€æ•°å­¦å…¬å¼ã€å¤æ‚åº¦åˆ†æå’Œå¯è§†åŒ–ç¤ºä¾‹ã€‚

#### 5.1 ç†è®ºåŸºç¡€

**è®ºæ–‡å®šä¹‰**ï¼ˆDefinition 11 & 13ï¼‰ï¼š

- **å¯åˆå¹¶æ€§ï¼ˆMergeable Tracesï¼‰**ï¼šä¸€ç»„è½¨è¿¹æ®µé›†åˆ $S$ å¯¹äºæ¨¡æ¿ NARX æ¨¡å‹ $N$ æ˜¯å¯åˆå¹¶çš„ï¼Œå½“ä¸”ä»…å½“å­˜åœ¨ $N \in \langle N \rangle$ ä½¿å¾— $N \models S$
- **æœ€å°å¯åˆå¹¶æ€§ï¼ˆMinimally Mergeableï¼‰**ï¼šæ‹Ÿåˆ $S$ æ‰€éœ€çš„æœ€å° NARX é˜¶æ•° $k_S$ ç­‰äºæ‹Ÿåˆä»»æ„å•ä¸ªæ®µçš„é˜¶æ•°

**åˆ¤æ–­æ¡ä»¶**ï¼š
$$\text{test\_set}(s_i, S_q) = (\text{order\_condition}) \land (\max(\text{err}) < \theta_{\text{fit}})$$

å…¶ä¸­ï¼š
- **é˜¶æ•°æ¡ä»¶**ï¼š$k_{\text{combined}} \leq \max(k_{s_i}, \min_{s \in S_q} k_s)$ï¼ˆæœ€å°å¯åˆå¹¶æ€§ï¼‰
- **è¯¯å·®æ¡ä»¶**ï¼š$\max(\text{err}) < \text{FitErrorThreshold}$ï¼ˆåŠ¨æ€æ ¡å‡†é˜ˆå€¼ï¼‰

#### 5.2 ç®—æ³•æ ¸å¿ƒï¼štest_set å‡½æ•°

**æ ¸å¿ƒæµ‹è¯•å‡½æ•°** (src/CurveSlice.py:90-104)ï¼š

```python
def test_set(self, other_list):
    """æµ‹è¯•å½“å‰æ•°æ®æ®µèƒ½å¦ä¸ other_list ä¸­çš„æ®µå…±åŒæ‹Ÿåˆ"""
    # æ”¶é›†å‚è€ƒæ®µçš„æ•°æ®å’Œæ‹Ÿåˆé˜¶æ•°
    data, input_data, other_fit_order = [], [], None
    for s in other_list:
        data.append(s.data)
        input_data.append(s.input_data)
        other_fit_order = min(other_fit_order, s.fit_order) if other_fit_order else s.fit_order
    
    # å°è¯•ç”¨å•ä¸€ NARX æ¨¡å‹æ‹Ÿåˆå½“å‰æ®µ+æ‰€æœ‰å‚è€ƒæ®µ
    _, err, fit_order = self.get_feature(
        [self.data] + data,
        [self.input_data] + input_data,
        is_list=True
    )
    
    # åˆ¤æ–­æ¡ä»¶1ï¼šæ‹Ÿåˆé˜¶æ•°ä¸å¢åŠ ï¼ˆæœ€å°å¯åˆå¹¶æ€§ï¼‰
    order_condition = all(
        fit_order[i] <= max(self.fit_order[i], other_fit_order[i])
        for i in range(len(fit_order))
    )
    
    # åˆ¤æ–­æ¡ä»¶2ï¼šæ‹Ÿåˆè¯¯å·®å°äºæ ¡å‡†çš„é˜ˆå€¼
    return order_condition and max(err) < Slice.FitErrorThreshold
```

**ä¸ºä»€ä¹ˆè¿™æ ·è®¾è®¡æœ‰æ•ˆï¼Ÿ**

å¦‚æœä¸¤ä¸ªæ•°æ®æ®µæ¥è‡ªåŒä¸€ä¸ªåŠ¨åŠ›å­¦æ¨¡å¼ $q$ï¼Œå®ƒä»¬éƒ½æ»¡è¶³ç›¸åŒçš„ NARX æ–¹ç¨‹ï¼š
$$\vec{x}[\tau] = F_q(\vec{x}[\tau-1], ..., \vec{x}[\tau-k], \vec{u}[\tau])$$

å› æ­¤ç”¨å•ä¸€ NARX æ¨¡å‹è”åˆæ‹Ÿåˆå®ƒä»¬åº”è¯¥ï¼š
1. **ä¸éœ€è¦å¢åŠ æ¨¡å‹é˜¶æ•°**ï¼šåŒä¸€ç‰©ç†è§„å¾‹ä¸‹ï¼Œæ—¶é—´ä¾èµ–æ·±åº¦åº”è¯¥ä¸€è‡´
2. **æ‹Ÿåˆè¯¯å·®ä¿æŒåœ¨å®¹å¿èŒƒå›´å†…**ï¼šåŒä¸€åŠ¨åŠ›å­¦æ–¹ç¨‹äº§ç”Ÿçš„æ•°æ®åº”è¯¥èƒ½è¢«ç»Ÿä¸€æè¿°

è¿™ç§åˆ¤æ–­æ–¹å¼**ç›´æ¥åŸºäºç‰©ç†æ„ä¹‰**ï¼ˆåŠ¨åŠ›å­¦æ–¹ç¨‹çš„ä¸€è‡´æ€§ï¼‰ï¼Œè€Œä¸æ˜¯å‚æ•°ç©ºé—´çš„å‡ ä½•è·ç¦»ï¼Œå› æ­¤å¯¹å™ªå£°å’Œå‚æ•°æ‰°åŠ¨æ›´é²æ£’ã€‚

#### 5.3 ä¸¤ç§èšç±»æ–¹æ³•

**æ–¹æ³•Aï¼šè·ç¦»æ–¹æ³• (`Method == 'dis'`)** - åŸºäºå‚æ•°å‘é‡çš„ L1 è·ç¦»

```python
if Slice.Method == 'dis':
    for j in range(i):
        if (data[j].mode != last_mode) and (data[i] & data[j]):
            data[i].setMode(data[j].mode)
            break
```

**`&` è¿ç®—ç¬¦**ï¼šæ¯”è¾ƒç‰¹å¾å‘é‡çš„ç›¸å¯¹è·ç¦»å’Œç»å¯¹è·ç¦»
$$v_1 \& v_2 = \text{True} \iff \forall i: (\text{relative\_dis}_i \leq \theta_{\text{rel}}[i]) \lor (\text{dis}_i \leq \theta_{\text{abs}}[i])$$

**æ–¹æ³•Bï¼šæ‹Ÿåˆæ–¹æ³• (`Method == 'fit'`)** - **æ¨èæ–¹æ³•**ï¼ŒåŸºäº NARX å¯åˆå¹¶æ€§

```python
else:  # 'fit' æ–¹æ³•
    fit_cnt = 0
    for idx, val in mode_dict.items():
        # æµ‹è¯•ï¼šå½“å‰æ•°æ®æ®µèƒ½å¦ä¸è¯¥æ¨¡å¼çš„ä»£è¡¨æ®µåˆå¹¶æ‹Ÿåˆï¼Ÿ
        if idx != last_mode and data[i].test_set(val):
            data[i].mode = idx
            fit_cnt += 1
    
    # æ ¹æ®åŒ¹é…ç»“æœåˆ†é…
    if fit_cnt == 1:
        if len(mode_dict[data[i].mode]) < 3:
            mode_dict[data[i].mode].append(data[i])  # æ·»åŠ ä¸ºä»£è¡¨æ®µ
    elif fit_cnt > 1:
        delay_list.append(data[i])  # æ­§ä¹‰ï¼Œå»¶è¿Ÿå¤„ç†
```

**å…³é”®è®¾è®¡**ï¼š
- **ä»£è¡¨æ®µé™åˆ¶**ï¼šæ¯ä¸ªæ¨¡å¼æœ€å¤šä¿ç•™3ä¸ªä»£è¡¨æ®µï¼Œå¹³è¡¡å‡†ç¡®æ€§å’Œæ•ˆç‡
- **å»¶è¿Ÿå¤„ç†**ï¼šæ­§ä¹‰æƒ…å†µï¼ˆåŒ¹é…å¤šä¸ªæ¨¡å¼ï¼‰å»¶è¿Ÿåˆ°ç¬¬äºŒé˜¶æ®µï¼Œåˆ©ç”¨æ›´å®Œæ•´çš„ä¸Šä¸‹æ–‡
- **æ—¶åºçº¦æŸ**ï¼šé€šè¿‡ `last_mode` é¿å…è¿ç»­åˆ†æ®µè¢«åˆ†åˆ°åŒä¸€æ¨¡å¼ï¼ˆé™¤é `self_loop=True`ï¼‰

#### 5.4 ä¸¤ç§æ–¹æ³•å¯¹æ¯”

| ç‰¹æ€§ | è·ç¦»æ–¹æ³• (`dis`) | æ‹Ÿåˆæ–¹æ³• (`fit`) |
|------|-----------------|------------------|
| **åˆ¤æ–­ä¾æ®** | å‚æ•°å‘é‡çš„ L1 è·ç¦» | NARX æ¨¡å‹çš„å¯åˆå¹¶æ€§ |
| **ç†è®ºåŸºç¡€** | å‡ ä½•è·ç¦» | ç‰©ç†æ„ä¹‰ï¼ˆæœ€å°å¯åˆå¹¶æ€§ï¼‰ |
| **è®¡ç®—å¤æ‚åº¦** | ä½ï¼ˆ$O(d)$ï¼‰ | ä¸­ç­‰ï¼ˆ$O(w \cdot d^2)$ï¼‰ |
| **é²æ£’æ€§** | å¯¹å™ªå£°æ•æ„Ÿ | å¯¹å™ªå£°é²æ£’ |
| **å»¶è¿Ÿå¤„ç†** | æ—  | æœ‰ï¼ˆç¬¬äºŒé˜¶æ®µï¼‰ |
| **æ¨èåœºæ™¯** | å¿«é€ŸåŸå‹ | ç”Ÿäº§ç¯å¢ƒ |

**æ¨èä½¿ç”¨ `fit` æ–¹æ³•**ï¼šç›´æ¥å¯¹åº”è®ºæ–‡ç†è®ºï¼ŒåŸºäºç‰©ç†æ„ä¹‰ï¼Œå¯¹å™ªå£°é²æ£’ã€‚

**ä»£ç å®ç°** (src/Clustering.py:4-61)ï¼š
```python
def clustering(data: list[Slice], self_loop=False):
    """
    åŸºäº NARX æ‹Ÿåˆèƒ½åŠ›çš„èšç±»ç®—æ³•

    æ ¸å¿ƒæ€æƒ³ï¼š
        - èƒ½è¢«åŒä¸€ç»„ NARX æ¨¡å‹æ‹Ÿåˆçš„æ•°æ®æ®µ â†’ åŒä¸€æ¨¡å¼
        - ç»´æŠ¤ mode_dict[mode_id] = [ä»£è¡¨æ€§æ•°æ®æ®µåˆ—è¡¨]
    """
    tot_mode = 1
    last_mode = None
    mode_dict = {}  # å­˜å‚¨æ¯ä¸ªæ¨¡å¼çš„ä»£è¡¨æ€§æ•°æ®æ®µ
    delay_list = []  # æš‚æ—¶æ— æ³•åˆ†ç±»çš„æ­§ä¹‰æ•°æ®æ®µ

    for i in range(len(data)):
        data[i].idx = i
        if not data[i].valid:
            continue
        if data[i].isFront:
            last_mode = None

        # æ–¹æ³•1ï¼šåŸºäºå‚æ•°è·ç¦»çš„èšç±»ï¼ˆ'dis' æ–¹æ³•ï¼‰
        if Slice.Method == 'dis':
            for j in range(i):
                if (data[j].mode != last_mode) and (data[i] & data[j]):
                    data[i].setMode(data[j].mode)
                if data[i].mode is not None:
                    break
        # æ–¹æ³•2ï¼šåŸºäºæ‹Ÿåˆèƒ½åŠ›çš„èšç±»ï¼ˆ'fit' æ–¹æ³•ï¼Œé»˜è®¤æ¨èï¼‰
        else:
            fit_cnt = 0
            # éå†å·²è¯†åˆ«çš„æ‰€æœ‰æ¨¡å¼
            for idx, val in mode_dict.items():
                # æµ‹è¯•ï¼šå½“å‰æ•°æ®æ®µèƒ½å¦è¢«è¯¥æ¨¡å¼çš„ä»£è¡¨æ®µæ‹Ÿåˆï¼Ÿ
                if idx != last_mode and data[i].test_set(val):
                    data[i].mode = idx
                    fit_cnt += 1
                # å¤„ç†äºŒé˜¶æ®µåŒ¹é…çš„ç‰¹æ®Šæƒ…å†µ
                elif len(val) == 2:
                    if data[i].test_set([val[0]]) or data[i].test_set([val[1]]):
                        delay_list.append(val[-1])
                        mode_dict[idx].pop()
                        fit_cnt = 2

            # æƒ…å†µ1ï¼šæ°å¥½åŒ¹é…ä¸€ä¸ªæ¨¡å¼
            if fit_cnt == 1:
                if len(mode_dict[data[i].mode]) < 3:
                    mode_dict[data[i].mode].append(data[i])  # æ·»åŠ ä¸ºä»£è¡¨æ®µ
            # æƒ…å†µ2ï¼šåŒ¹é…å¤šä¸ªæ¨¡å¼ï¼ˆæ­§ä¹‰ï¼‰
            elif fit_cnt > 1:
                delay_list.append(data[i])
                data[i].mode = -1

        # æƒ…å†µ3ï¼šä¸åŒ¹é…ä»»ä½•ç°æœ‰æ¨¡å¼ â†’ åˆ›å»ºæ–°æ¨¡å¼
        if data[i].mode is None:
            data[i].mode = tot_mode
            mode_dict[tot_mode] = [data[i]]
            tot_mode += 1

        if not self_loop:
            last_mode = data[i].mode

    # 'dis' æ–¹æ³•ä¸éœ€è¦ç¬¬äºŒé˜¶æ®µå¤„ç†ï¼Œç›´æ¥è¿”å›
    if Slice.Method != 'fit':
        return

    # ç¬¬äºŒé˜¶æ®µï¼šå¤„ç†æ­§ä¹‰æ•°æ®æ®µï¼ˆä»…ç”¨äº 'fit' æ–¹æ³•ï¼‰
    for s in delay_list:
        for idx, val in mode_dict.items():
            # åˆ©ç”¨æ—¶åºä¿¡æ¯ï¼šè·³è¿‡å‰ä¸€æ®µçš„æ¨¡å¼ï¼ˆé¿å…è‡ªç¯ï¼‰
            if not s.isFront and data[s.idx - 1].mode == idx:
                continue
            if s.test_set(val):
                s.mode = idx
                if len(val) < 3:
                    mode_dict[idx].append(s)
                break
        # ä»æ— æ³•åŒ¹é… â†’ åˆ›å»ºæ–°æ¨¡å¼
        if s.mode is None or s.mode == -1:
            s.mode = tot_mode
            mode_dict[tot_mode] = [s]
            tot_mode += 1
```

**test_set å‡½æ•°** (src/CurveSlice.py:90-104)ï¼š
```python
def test_set(self, other_list):
    """æµ‹è¯•å½“å‰æ•°æ®æ®µèƒ½å¦è¢« other_list ä¸­çš„æ®µå…±åŒæ‹Ÿåˆ"""
    data, input_data, other_fit_order = [], [], None

    # æ”¶é›†å‚è€ƒæ®µçš„æ•°æ®
    for s in other_list:
        data.append(s.data)
        input_data.append(s.input_data)
        if other_fit_order is None:
            other_fit_order = copy.copy(s.fit_order)
        else:
            other_fit_order = min(other_fit_order, s.fit_order)

    # å°è¯•ç”¨å•ä¸€ NARX æ¨¡å‹æ‹Ÿåˆå½“å‰æ®µ+æ‰€æœ‰å‚è€ƒæ®µ
    _, err, fit_order = self.get_feature([self.data] + data,
                                        [self.input_data] + input_data,
                                        is_list=True)

    # åˆ¤æ–­æ¡ä»¶ï¼š
    # 1. æ‹Ÿåˆé˜¶æ•°ä¸å¢åŠ ï¼ˆæ¨¡å‹å¤æ‚åº¦ä¸å˜ï¼‰
    # 2. æ‹Ÿåˆè¯¯å·®å°äºæ ¡å‡†çš„é˜ˆå€¼
    order_condition = True
    for i in range(len(fit_order)):
        order_condition = order_condition and \
                         fit_order[i] <= max(self.fit_order[i], other_fit_order[i])

    return order_condition and max(err) < Slice.FitErrorThreshold
```

**ä¸ºä»€ä¹ˆè¿™æ ·è®¾è®¡æœ‰æ•ˆï¼Ÿ**

å¦‚æœä¸¤ä¸ªæ•°æ®æ®µæ¥è‡ªåŒä¸€ä¸ªåŠ¨åŠ›å­¦æ¨¡å¼ï¼Œé‚£ä¹ˆç”¨å•ä¸€ NARX æ¨¡å‹è”åˆæ‹Ÿåˆå®ƒä»¬åº”è¯¥ï¼š
1. **ä¸éœ€è¦å¢åŠ æ¨¡å‹é˜¶æ•°**ï¼šåŒä¸€ç‰©ç†è§„å¾‹ä¸‹ï¼Œæ—¶é—´ä¾èµ–æ·±åº¦åº”è¯¥ä¸€è‡´
2. **æ‹Ÿåˆè¯¯å·®ä¿æŒåœ¨å®¹å¿èŒƒå›´å†…**ï¼šåŒä¸€åŠ¨åŠ›å­¦æ–¹ç¨‹äº§ç”Ÿçš„æ•°æ®åº”è¯¥èƒ½è¢«ç»Ÿä¸€æè¿°

è¿™ç§åˆ¤æ–­æ–¹å¼**ç›´æ¥åŸºäºç‰©ç†æ„ä¹‰**ï¼Œè€Œä¸æ˜¯å‚æ•°ç©ºé—´çš„å‡ ä½•è·ç¦»ã€‚

**èšç±»è¿‡ç¨‹ç¤ºæ„**ï¼š
```
æ®µ1 æ®µ2 æ®µ3 æ®µ4 æ®µ5 æ®µ6
 â†“   â†“   â†“   â†“   â†“   â†“
[æ®µ1] â†’ æ¨¡å¼1
[æ®µ2] test_set([æ®µ1]) â†’ é€šè¿‡ â†’ æ¨¡å¼1
[æ®µ3] test_set([æ®µ1,æ®µ2]) â†’ å¤±è´¥ â†’ æ¨¡å¼2
[æ®µ4] test_set([æ®µ1,æ®µ2]) â†’ é€šè¿‡ â†’ æ¨¡å¼1
[æ®µ5] test_set([æ®µ3]) â†’ é€šè¿‡ â†’ æ¨¡å¼2
[æ®µ6] test_set([æ®µ1,æ®µ2,æ®µ4]) â†’ å¤±è´¥ â†’ test_set([æ®µ3,æ®µ5]) â†’ å¤±è´¥ â†’ æ¨¡å¼3
```
### 6. Guard Learning and Reset Learning

Guard Learning å’Œ Reset Learning æ˜¯æ··åˆè‡ªåŠ¨æœºè¯†åˆ«çš„æœ€åä¸¤ä¸ªå…³é”®æ­¥éª¤ï¼Œåˆ†åˆ«è´Ÿè´£å­¦ä¹ **æ¨¡å¼åˆ‡æ¢çš„è§¦å‘æ¡ä»¶**å’Œ**åˆ‡æ¢æ—¶çš„çŠ¶æ€é‡ç½®è§„åˆ™**ã€‚

#### 6.1 Guard Learningï¼šåŸºäº SVM çš„åˆ‡æ¢æ¡ä»¶å­¦ä¹ 

**æ ¸å¿ƒæ€æƒ³**ï¼šå°†å®ˆå«æ¡ä»¶å­¦ä¹ è½¬åŒ–ä¸º**äºŒåˆ†ç±»é—®é¢˜** â€”â€” å¯¹äºæ¯ä¸ªæ¨¡å¼å¯¹ $(q, q')$ï¼Œå­¦ä¹ ä¸€ä¸ªåˆ†ç±»å™¨æ¥åˆ¤æ–­"åœ¨å½“å‰çŠ¶æ€ä¸‹ï¼Œç³»ç»Ÿæ˜¯å¦ä¼šä»æ¨¡å¼ $q$ åˆ‡æ¢åˆ°æ¨¡å¼ $q'$"ã€‚

##### 6.1.1 æ­£è´Ÿæ ·æœ¬æ„é€ ç­–ç•¥

**ä»£ç å®ç°** (src/GuardLearning.py:8-31)ï¼š

```python
def guard_learning(data: list[Slice], get_feature, config):
    """å­¦ä¹ å®ˆå«æ¡ä»¶å’Œé‡ç½®å‡½æ•°"""
    positive_sample = {}  # æ­£æ ·æœ¬ï¼šå‘ç”Ÿåˆ‡æ¢çš„çŠ¶æ€ç‚¹
    negative_sample = {}  # è´Ÿæ ·æœ¬ï¼šæœªå‘ç”Ÿåˆ‡æ¢çš„çŠ¶æ€ç‚¹
    slice_data = {}       # ç”¨äºé‡ç½®å‡½æ•°å­¦ä¹ çš„æ•°æ®æ®µå¯¹
    need_reset = config['need_reset']
    
    # éå†æ‰€æœ‰æ•°æ®æ®µï¼Œæ”¶é›†æ­£è´Ÿæ ·æœ¬
    for i in range(len(data)):
        if not data[i].valid:
            continue
        mode = data[i].mode
        
        # 1ï¸âƒ£ è´Ÿæ ·æœ¬æ”¶é›†ï¼šå½“å‰æ¨¡å¼å†…çš„æ‰€æœ‰çŠ¶æ€ç‚¹ï¼ˆé™¤æœ€åä¸€ä¸ªï¼‰
        if negative_sample.get(mode) is None:
            negative_sample[mode] = []
        # è½¬ç½®åæ¯è¡Œæ˜¯ä¸€ä¸ªçŠ¶æ€å‘é‡ [xâ‚, xâ‚‚, ..., xâ‚™]
        negative_sample[mode].append(np.transpose(data[i].data[:, :-1]))
        
        # è·³è¿‡è½¨è¿¹èµ·ç‚¹æˆ–æ— æ•ˆæ®µ
        if i == 0 or not data[i - 1].valid or data[i].isFront:
            continue
        
        # 2ï¸âƒ£ æ­£æ ·æœ¬æ”¶é›†ï¼šå‘ç”Ÿæ¨¡å¼åˆ‡æ¢çš„è¾¹ç•Œç‚¹
        idx = (data[i - 1].mode, data[i].mode)  # åˆ‡æ¢å¯¹ (æºæ¨¡å¼, ç›®æ ‡æ¨¡å¼)
        if positive_sample.get(idx) is None:
            positive_sample[idx] = []
            slice_data[idx] = [[], []] if need_reset else None
        
        # ä¿å­˜åˆ‡æ¢å‰çš„æœ€åä¸€ä¸ªçŠ¶æ€ç‚¹
        positive_sample[idx].append(data[i - 1].data[:, -1])
        
        # å¦‚æœéœ€è¦å­¦ä¹ é‡ç½®å‡½æ•°ï¼Œä¿å­˜åˆ‡æ¢å‰åçš„æ•°æ®æ®µ
        if need_reset:
            slice_data[idx][0].append(data[i - 1])  # åˆ‡æ¢å‰çš„æ®µ
            slice_data[idx][1].append(data[i])      # åˆ‡æ¢åçš„æ®µ
    
    # åˆå¹¶æ‰€æœ‰è´Ÿæ ·æœ¬
    for (key, val) in negative_sample.items():
        negative_sample[key] = np.concatenate(val)
```

**æ ·æœ¬æ„é€ çš„æ•°å­¦å®šä¹‰**ï¼ˆå¯¹åº”è®ºæ–‡ Section 4.5ï¼‰ï¼š

å¯¹äºä»»æ„æ¨¡å¼å¯¹ $(q, q') \in \hat{Q} \times \hat{Q}$ï¼š

$$
(q, q')^+ = \bigcup_{j=1}^M \{\xi_j(\tau) \mid M_j(\tau) = q \text{ ä¸” } M_j(\tau+1) = q'\}
$$

$$
(q, q')^- = \bigcup_{j=1}^M \{\xi_j(\tau) \mid M_j(\tau) = q \text{ ä¸” } M_j(\tau+1) \neq q'\}
$$

å…¶ä¸­ï¼š
- $\xi_j(\tau)$ æ˜¯ç¬¬ $j$ æ¡è½¨è¿¹åœ¨æ—¶åˆ» $\tau$ çš„çŠ¶æ€å‘é‡ $(\vec{x}[\tau], \vec{u}[\tau])$
- $M_j(\tau)$ æ˜¯è¯¥æ—¶åˆ»æ‰€å±çš„æ¨¡å¼
- $(q, q')^+$ æ˜¯**æ­£æ ·æœ¬é›†**ï¼šæ‰€æœ‰å¯¼è‡´ $q \to q'$ åˆ‡æ¢çš„çŠ¶æ€ç‚¹
- $(q, q')^-$ æ˜¯**è´Ÿæ ·æœ¬é›†**ï¼šæ‰€æœ‰åœ¨æ¨¡å¼ $q$ ä½†æœªåˆ‡æ¢åˆ° $q'$ çš„çŠ¶æ€ç‚¹

**å…³é”®è®¾è®¡æ´å¯Ÿ**ï¼š

1. **è´Ÿæ ·æœ¬çš„å·§å¦™å®šä¹‰**ï¼šä¸æ˜¯"æ‰€æœ‰ä¸å±äº $q$ çš„çŠ¶æ€"ï¼Œè€Œæ˜¯"å±äº $q$ ä½†æœªåˆ‡æ¢åˆ° $q'$ çš„çŠ¶æ€"
   - è¿™æ ·å®šä¹‰çš„è´Ÿæ ·æœ¬ä¸æ­£æ ·æœ¬åœ¨**åŒä¸€æ¨¡å¼å†…**ï¼Œåªæ˜¯åˆ‡æ¢ç›®æ ‡ä¸åŒ
   - é¿å…äº†"æ¨¡å¼å†…éƒ¨çŠ¶æ€ vs åˆ‡æ¢è¾¹ç•ŒçŠ¶æ€"è¿™ç§è¿‡äºç®€å•çš„åˆ†ç±»é—®é¢˜
   - ä½¿ SVM å­¦åˆ°çš„å†³ç­–è¾¹ç•Œæ›´ç²¾ç¡®åœ°åˆ»ç”»"ä½•æ—¶è§¦å‘ç‰¹å®šåˆ‡æ¢"

2. **æ ·æœ¬ä¸å¹³è¡¡é—®é¢˜**ï¼šè´Ÿæ ·æœ¬æ•°é‡é€šå¸¸è¿œå¤§äºæ­£æ ·æœ¬ï¼ˆä¸€ä¸ªæ¨¡å¼å†…å¤§éƒ¨åˆ†æ—¶é—´ä¸å‘ç”Ÿåˆ‡æ¢ï¼‰
   - é€šè¿‡ `class_weight` å‚æ•°è°ƒæ•´ï¼š`class_weight={0: config['class_weight'], 1: 1}`
   - é»˜è®¤ `class_weight=1.0`ï¼Œå¯æ ¹æ®å®é™…æƒ…å†µè°ƒæ•´è´Ÿæ ·æœ¬æƒé‡

##### 6.1.2 SVM è®­ç»ƒä¸å®ˆå«æ¡ä»¶æå–

**ä»£ç å®ç°** (src/GuardLearning.py:37-44)ï¼š

```python
adj = {}
for (u, v), sample in positive_sample.items():
    # åˆå§‹åŒ– SVM åˆ†ç±»å™¨
    svc = SVC(
        C=config['svm_c'],           # æ­£åˆ™åŒ–å‚æ•°ï¼ˆé»˜è®¤ 1e6ï¼Œå¼ºè°ƒæ‹Ÿåˆç²¾åº¦ï¼‰
        kernel=config['kernel'],      # æ ¸å‡½æ•°ï¼š'linear', 'rbf', 'poly' ç­‰
        class_weight={0: config['class_weight'], 1: 1}  # ç±»åˆ«æƒé‡
    )
    
    # æ„é€ è®­ç»ƒæ•°æ®
    # æ ‡ç­¾ï¼š0 = è´Ÿæ ·æœ¬ï¼ˆä¸åˆ‡æ¢åˆ° vï¼‰ï¼Œ1 = æ­£æ ·æœ¬ï¼ˆåˆ‡æ¢åˆ° vï¼‰
    label = np.concatenate((
        np.zeros(negative_sample[u].shape[0]),  # è´Ÿæ ·æœ¬æ ‡ç­¾
        np.ones(len(positive_sample[(u, v)]))   # æ­£æ ·æœ¬æ ‡ç­¾
    ))
    
    # ç‰¹å¾ï¼šçŠ¶æ€å‘é‡ (xâ‚, xâ‚‚, ..., xâ‚™, uâ‚, uâ‚‚, ..., uâ‚˜)
    sample = np.concatenate((
        negative_sample[u],      # æ¨¡å¼ u å†…çš„éåˆ‡æ¢çŠ¶æ€
        positive_sample[(u, v)]  # u â†’ v åˆ‡æ¢è¾¹ç•Œçš„çŠ¶æ€
    ))
    
    # è®­ç»ƒ SVM
    svc.fit(sample, label)
    
    # å­˜å‚¨ï¼šé‚»æ¥è¡¨ adj[(u, v)] = (å®ˆå«åˆ†ç±»å™¨, é‡ç½®å‡½æ•°)
    adj[(u, v)] = (svc, slice_data[(u, v)])

return adj
```

**SVM å†³ç­–å‡½æ•°çš„ç‰©ç†æ„ä¹‰**ï¼š

è®­ç»ƒåçš„ SVM æ¨¡å‹ `svc` å®šä¹‰äº†ä¸€ä¸ªå†³ç­–å‡½æ•° $g_{q \to q'}: \mathbb{R}^{n+m} \to \{0, 1\}$ï¼š

$$
g_{q \to q'}(\vec{x}, \vec{u}) = 
\begin{cases}
1 & \text{å¦‚æœ } f_{\text{SVM}}(\vec{x}, \vec{u}) > 0.5 \\
0 & \text{å¦åˆ™}
\end{cases}
$$

å…¶ä¸­ $f_{\text{SVM}}$ æ˜¯ SVM çš„å†³ç­–å‡½æ•°ï¼ˆå¯¹äº RBF æ ¸ï¼Œè¿™æ˜¯ä¸€ä¸ªéçº¿æ€§å‡½æ•°ï¼‰ã€‚

**æ ¸å‡½æ•°é€‰æ‹©**ï¼š

| æ ¸å‡½æ•° | é€‚ç”¨åœºæ™¯ | ç¤ºä¾‹ç³»ç»Ÿ |
|--------|---------|---------|
| `linear` | çº¿æ€§å®ˆå«æ¡ä»¶ï¼ˆå¦‚ $x_1 + x_2 \leq c$ï¼‰ | æ¸©æ§ç³»ç»Ÿã€ç®€å•å¼€å…³ç³»ç»Ÿ |
| `rbf` | éçº¿æ€§å®ˆå«æ¡ä»¶ï¼ˆå¦‚ $x^2 + y^2 \leq r^2$ï¼‰ | Duffing æŒ¯å­ã€å¼¹è·³çƒ |
| `poly` | å¤šé¡¹å¼å®ˆå«æ¡ä»¶ï¼ˆå¦‚ $x^3 - 2x \geq 0$ï¼‰ | é«˜é˜¶éçº¿æ€§ç³»ç»Ÿ |

**Duffing æŒ¯å­ç¤ºä¾‹**ï¼š

çœŸå®å®ˆå«æ¡ä»¶ï¼š
- $q_1 \to q_2$: $|x| \leq 0.8$
- $q_2 \to q_1$: $|x| \geq 1.2$

ä½¿ç”¨ `kernel='rbf'` çš„ SVM å¯ä»¥å­¦ä¹ åˆ°è¿‘ä¼¼çš„éçº¿æ€§å†³ç­–è¾¹ç•Œã€‚

##### 6.1.3 å®ˆå«æ¡ä»¶åœ¨ä»¿çœŸä¸­çš„åº”ç”¨

**ä»£ç å®ç°** (src/BuildSystem.py:10-16)ï¼š

```python
class ModelFun:
    """å°† SVM æ¨¡å‹åŒ…è£…ä¸ºå¯è°ƒç”¨çš„å®ˆå«å‡½æ•°"""
    def __init__(self, model):
        self.model = copy.copy(model)
    
    def __call__(self, *args):
        """è¾“å…¥çŠ¶æ€å‘é‡ï¼Œè¿”å›å¸ƒå°”å€¼ï¼ˆæ˜¯å¦è§¦å‘åˆ‡æ¢ï¼‰"""
        return self.model.predict([[*args]])[0] > 0.5
```

**åœ¨æ··åˆè‡ªåŠ¨æœºä¸­çš„ä½¿ç”¨** (src/HybridAutomata.py:89-103)ï¼š

```python
def next(self, *args):
    """æ‰§è¡Œä¸€æ­¥ä»¿çœŸï¼Œæ£€æµ‹æ¨¡å¼åˆ‡æ¢"""
    # 1. åœ¨å½“å‰æ¨¡å¼ä¸‹æ‰§è¡Œä¸€æ­¥åŠ¨åŠ›å­¦æ¼”åŒ–
    res = list(self.mode_list[self.mode_state].next(*args))
    
    # 2. æ£€æŸ¥æ‰€æœ‰å¯èƒ½çš„å‡ºè¾¹
    for to, fun, reset_val in self.adj.get(self.mode_state, {}):
        # 3. è°ƒç”¨å®ˆå«å‡½æ•°åˆ¤æ–­æ˜¯å¦è§¦å‘åˆ‡æ¢
        if fun(*res):  # â† è¿™é‡Œè°ƒç”¨ ModelFunï¼Œå³ SVM åˆ†ç±»å™¨
            self.mode_state = to
            # 4. æ‰§è¡ŒçŠ¶æ€é‡ç½®
            self.mode_list[to].load(self.mode_list[mode_state], reset_val)
            break
    
    return res, mode_state, switched
```

#### 6.2 Reset Learningï¼šé«˜é˜¶ç³»ç»Ÿçš„çŠ¶æ€é‡ç½®å­¦ä¹ 

**æ ¸å¿ƒæŒ‘æˆ˜**ï¼šå¯¹äºé«˜é˜¶ç³»ç»Ÿï¼ˆ$k > 1$ï¼‰ï¼Œæ¨¡å¼åˆ‡æ¢æ—¶ä¸ä»…éœ€è¦é‡ç½®å½“å‰çŠ¶æ€ $\vec{x}[\tau]$ï¼Œè¿˜éœ€è¦é‡ç½®å†å²çŠ¶æ€ $\vec{x}[\tau-1], \vec{x}[\tau-2], \ldots, \vec{x}[\tau-k+1]$ï¼Œå› ä¸º NARX æ¨¡å‹ä¾èµ–äºè¿™äº›å†å²å€¼ã€‚

##### 6.2.1 é‡ç½®å‡½æ•°çš„æ•°å­¦å½¢å¼

**è®ºæ–‡å®šä¹‰**ï¼ˆEquation 7ï¼‰ï¼š

å¯¹äºé«˜é˜¶åŠ¨åŠ›å­¦ï¼ˆ$k > 1$ï¼‰ï¼Œé‡ç½®å‡½æ•°å®šä¹‰ä¸ºï¼š

$$
r: \mathbb{R}^{k \times n + m} \to \langle N \rangle^k
$$

$$
(\vec{x}[\tau], \vec{x}[\tau-1], \ldots, \vec{x}[\tau-k+1], \vec{u}[\tau]) \mapsto \{N_1, N_2, \ldots, N_k\}
$$

å…¶ä¸­æ¯ä¸ª $N_i$ æ˜¯ä¸€ä¸ª NARX æ¨¡å‹ï¼Œç”¨äºç”Ÿæˆåˆ‡æ¢åçš„ç¬¬ $i$ ä¸ªæ—¶é—´æ­¥çš„çŠ¶æ€ï¼š

$$
N_i: (\vec{x}[\tau-1+i], \ldots, \vec{x}[\tau-k+i], \vec{u}[\tau+i]) \mapsto \vec{x}[\tau+i]
$$

**ç‰©ç†æ„ä¹‰**ï¼š

- ä¼ ç»Ÿé‡ç½®ï¼ˆ$k=1$ï¼‰ï¼š$\vec{x}'[\tau] = r(\vec{x}[\tau])$ï¼Œåªé‡ç½®å½“å‰çŠ¶æ€
- é«˜é˜¶é‡ç½®ï¼ˆ$k>1$ï¼‰ï¼šéœ€è¦ç”Ÿæˆ $k$ ä¸ªè¿ç»­çš„æ–°çŠ¶æ€ $\vec{x}[\tau], \vec{x}[\tau+1], \ldots, \vec{x}[\tau+k-1]$ï¼Œä»¥å¡«å……æ–°æ¨¡å¼çš„ NARX æ¨¡å‹æ‰€éœ€çš„å†å²çª—å£

##### 6.2.2 é‡ç½®å‡½æ•°çš„å­¦ä¹ è¿‡ç¨‹

**æ•°æ®å‡†å¤‡** (src/Reset.py:14-27)ï¼š

```python
@classmethod
def from_slice(cls, get_feature: FeatureExtractor, f_list: list[Slice], t_list: list[Slice]):
    """
    ä»åˆ‡æ¢å‰åçš„æ•°æ®æ®µå¯¹å­¦ä¹ é‡ç½®å‡½æ•°
    
    å‚æ•°ï¼š
        f_list: åˆ‡æ¢å‰çš„æ•°æ®æ®µåˆ—è¡¨ï¼ˆfrom slicesï¼‰
        t_list: åˆ‡æ¢åçš„æ•°æ®æ®µåˆ—è¡¨ï¼ˆto slicesï¼‰
    """
    # ç¡®å®šéœ€è¦ç”Ÿæˆçš„æ—¶é—´æ­¥æ•°ï¼ˆå–æœ€å¤§æ‹Ÿåˆé˜¶æ•°ï¼‰
    fit_order = max(max(s.fit_order for s in t_list))
    eq_list = []
    
    # ä¸ºæ¯ä¸ªæ—¶é—´æ­¥ i âˆˆ [0, fit_order-1] å­¦ä¹ ä¸€ä¸ª NARX æ¨¡å‹
    for i in range(fit_order):
        this_data = []
        this_input = []
        
        # éå†æ‰€æœ‰åˆ‡æ¢äº‹ä»¶
        for f_slice, t_slice in zip(f_list, t_list):
            # æ„é€ è®­ç»ƒæ•°æ®ï¼šæ‹¼æ¥åˆ‡æ¢å‰åçš„çŠ¶æ€
            # ç‰¹å¾ï¼š[x[Ï„-k+i], ..., x[Ï„-1], x[Ï„], ..., x[Ï„+i]]
            this_data.append(np.concatenate((
                f_slice.data[:, -(get_feature.order - i):],  # åˆ‡æ¢å‰çš„æœ€å (order-i) ä¸ªç‚¹
                t_slice.data[:, :(i + 1)]                    # åˆ‡æ¢åçš„å‰ (i+1) ä¸ªç‚¹
            ), axis=1))
            
            # è¾“å…¥æ•°æ®åŒæ ·æ‹¼æ¥
            this_input.append(np.concatenate((
                f_slice.input_data[:, -(get_feature.order - i):],
                t_slice.input_data[:, :(i + 1)]
            ), axis=1))
        
        # æ‹Ÿåˆç¬¬ i ä¸ª NARX æ¨¡å‹
        eq_list.append(get_feature(this_data, this_input, is_list=True)[0])
    
    return cls(get_feature, fit_order, eq_list)
```

**æ•°æ®æ‹¼æ¥ç¤ºä¾‹**ï¼ˆå‡è®¾ `order=3`, `fit_order=2`ï¼‰ï¼š

```
åˆ‡æ¢å‰æ•°æ®æ®µ f_slice:  [..., x[-3], x[-2], x[-1]]
åˆ‡æ¢åæ•°æ®æ®µ t_slice:  [x[0], x[1], x[2], ...]
                              â†‘ åˆ‡æ¢ç‚¹

å­¦ä¹  Nâ‚€ï¼ˆç”Ÿæˆ x[0]ï¼‰ï¼š
  ç‰¹å¾çª—å£ï¼š[x[-3], x[-2], x[-1]]  â† å…¨éƒ¨æ¥è‡ªåˆ‡æ¢å‰
  ç›®æ ‡å€¼ï¼š  x[0]                   â† åˆ‡æ¢åç¬¬ä¸€ä¸ªç‚¹

å­¦ä¹  Nâ‚ï¼ˆç”Ÿæˆ x[1]ï¼‰ï¼š
  ç‰¹å¾çª—å£ï¼š[x[-2], x[-1], x[0]]  â† éƒ¨åˆ†æ¥è‡ªåˆ‡æ¢å‰ï¼Œéƒ¨åˆ†æ¥è‡ªåˆ‡æ¢å
  ç›®æ ‡å€¼ï¼š  x[1]                   â† åˆ‡æ¢åç¬¬äºŒä¸ªç‚¹
```

**å…³é”®è®¾è®¡æ´å¯Ÿ**ï¼š

1. **æ¸è¿›å¼é‡ç½®**ï¼šä¸æ˜¯ä¸€æ¬¡æ€§é‡ç½®æ‰€æœ‰å†å²çŠ¶æ€ï¼Œè€Œæ˜¯é€æ­¥ç”Ÿæˆ $k$ ä¸ªæ–°çŠ¶æ€
   - $N_0$ ä½¿ç”¨åˆ‡æ¢å‰çš„å†å²ç”Ÿæˆ $x[\tau]$
   - $N_1$ ä½¿ç”¨ $x[\tau]$ å’Œéƒ¨åˆ†å†å²ç”Ÿæˆ $x[\tau+1]$
   - ä»¥æ­¤ç±»æ¨ï¼Œç›´åˆ°å¡«æ»¡æ–°æ¨¡å¼çš„å†å²çª—å£

2. **è·¨æ¨¡å¼æ•°æ®èåˆ**ï¼šè®­ç»ƒæ•°æ®æ¨ªè·¨åˆ‡æ¢è¾¹ç•Œï¼Œæ•æ‰"ä»æ—§æ¨¡å¼çŠ¶æ€åˆ°æ–°æ¨¡å¼çŠ¶æ€"çš„è½¬æ¢è§„å¾‹

##### 6.2.3 é‡ç½®å‡½æ•°çš„æ‰§è¡Œ

**ä»£ç å®ç°** (src/Reset.py:29-40)ï¼š

```python
def __call__(self, state, input_data, var_num):
    """æ‰§è¡Œä¸€æ­¥é‡ç½®è®¡ç®—"""
    res = []
    for i in range(var_num):
        # ä½¿ç”¨ç¬¬ cnt ä¸ª NARX æ¨¡å‹è®¡ç®—æ–°çŠ¶æ€
        res.append(np.dot(
            self.get_feature.get_items(state, input_data, i),  # ç‰¹å¾å‘é‡
            self.eq_list[self.cnt][i]                          # NARX å‚æ•°
        ))
    self.cnt += 1  # ç§»åŠ¨åˆ°ä¸‹ä¸€ä¸ªæ—¶é—´æ­¥
    return res

def valid(self):
    """æ£€æŸ¥æ˜¯å¦è¿˜éœ€è¦ç»§ç»­é‡ç½®"""
    return self.cnt < self.fit_order

def clear(self):
    """é‡ç½®è®¡æ•°å™¨"""
    self.cnt = 0
```

**åœ¨å·®åˆ†æ–¹ç¨‹ç³»ç»Ÿä¸­çš„åº”ç”¨** (src/DE_System.py:34-50)ï¼š

```python
def next(self, input_val=None):
    """æ‰§è¡Œä¸€æ­¥ä»¿çœŸ"""
    if input_val is None:
        input_val = []
    res = []
    
    # æ›´æ–°è¾“å…¥é˜Ÿåˆ—
    for i in range(self.config.input_num):
        self.input_data[i].appendleft(input_val[i])
    
    # å…³é”®åˆ¤æ–­ï¼šæ˜¯å¦å¤„äºé‡ç½®é˜¶æ®µï¼Ÿ
    if self.reset_fun is None or not self.reset_fun.valid():
        # æ­£å¸¸æ¨¡å¼ï¼šä½¿ç”¨å½“å‰æ¨¡å¼çš„ NARX æ¨¡å‹
        for i in range(self.var_num):
            res.append(np.dot(
                self.config.get_items(self.state, self.input_data, i),
                self.eq[i]
            ))
    else:
        # é‡ç½®æ¨¡å¼ï¼šä½¿ç”¨é‡ç½®å‡½æ•°ç”ŸæˆçŠ¶æ€
        res = self.reset_fun(self.state, self.input_data, self.var_num)
    
    # æ›´æ–°çŠ¶æ€é˜Ÿåˆ—
    for i in range(self.var_num):
        self.state[i].pop()
        self.state[i].appendleft(res[i])
    
    return res
```

**æ‰§è¡Œæµç¨‹ç¤ºæ„**ï¼ˆ`order=3`, `fit_order=2`ï¼‰ï¼š

```
æ—¶åˆ» Ï„-1ï¼šæ¨¡å¼ qâ‚ï¼ŒçŠ¶æ€é˜Ÿåˆ— = [x[-1], x[-2], x[-3]]
  â†“ å®ˆå«æ¡ä»¶è§¦å‘ï¼Œåˆ‡æ¢åˆ°æ¨¡å¼ qâ‚‚
æ—¶åˆ» Ï„ï¼š  é‡ç½®é˜¶æ®µï¼ˆcnt=0ï¼‰
  â†’ è°ƒç”¨ reset_fun()ï¼Œä½¿ç”¨ Nâ‚€ ç”Ÿæˆ x[0]
  â†’ çŠ¶æ€é˜Ÿåˆ— = [x[0], x[-1], x[-2]]
æ—¶åˆ» Ï„+1ï¼šé‡ç½®é˜¶æ®µï¼ˆcnt=1ï¼‰
  â†’ è°ƒç”¨ reset_fun()ï¼Œä½¿ç”¨ Nâ‚ ç”Ÿæˆ x[1]
  â†’ çŠ¶æ€é˜Ÿåˆ— = [x[1], x[0], x[-1]]
æ—¶åˆ» Ï„+2ï¼šæ­£å¸¸é˜¶æ®µï¼ˆcnt=2, è¾¾åˆ° fit_orderï¼‰
  â†’ ä½¿ç”¨æ¨¡å¼ qâ‚‚ çš„ NARX æ¨¡å‹ç”Ÿæˆ x[2]
  â†’ çŠ¶æ€é˜Ÿåˆ— = [x[2], x[1], x[0]]
```

##### 6.2.4 é‡ç½®å‡½æ•°çš„å¿…è¦æ€§åˆ†æ

**ä½•æ—¶éœ€è¦ `need_reset=true`ï¼Ÿ**

| ç³»ç»Ÿç‰¹æ€§ | æ˜¯å¦éœ€è¦é‡ç½® | åŸå›  |
|---------|------------|------|
| **ä¸€é˜¶ç³»ç»Ÿ** ($k=1$) | å¯é€‰ | åªæœ‰å½“å‰çŠ¶æ€ï¼Œé€šå¸¸å¯ä»¥ç›´æ¥ç»§æ‰¿ |
| **é«˜é˜¶ç³»ç»Ÿ** ($k>1$) | **å¼ºçƒˆæ¨è** | å†å²çŠ¶æ€å¯èƒ½ä¸å…¼å®¹æ–°æ¨¡å¼çš„åŠ¨åŠ›å­¦ |
| **è¿ç»­åˆ‡æ¢** | å¿…éœ€ | çŠ¶æ€è·³å˜ï¼ˆå¦‚å¼¹è·³çƒé€Ÿåº¦åè½¬ï¼‰ |
| **å¹³æ»‘åˆ‡æ¢** | å¯é€‰ | çŠ¶æ€è¿ç»­ï¼ˆå¦‚æ¸©æ§ç³»ç»Ÿï¼‰ |

**Duffing æŒ¯å­é…ç½®ç¤ºä¾‹** (automata/non_linear/duffing.json:54)ï¼š

```json
{
  "config": {
    "order": 2,
    "need_reset": true,  // â† å› ä¸ºæ˜¯äºŒé˜¶ç³»ç»Ÿ
    "kernel": "rbf"
  }
}
```

çœŸå®é‡ç½®è§„åˆ™ï¼š`x[1] = x[1] * 0.95`ï¼ˆé€Ÿåº¦è¡°å‡ 5%ï¼‰

**å®éªŒè§‚å¯Ÿ**ï¼š
- å¯ç”¨ `need_reset=true`ï¼šå­¦ä¹ åˆ°çš„é‡ç½®å‡½æ•°èƒ½å‡†ç¡®æ•æ‰é€Ÿåº¦è¡°å‡
- ç¦ç”¨ `need_reset=false`ï¼šåˆ‡æ¢åçš„è½¨è¿¹ä¼šå‡ºç°æ˜æ˜¾åå·®ï¼Œå› ä¸ºå†å²çŠ¶æ€ä¸åŒ¹é…æ–°æ¨¡å¼

#### 6.3 å®Œæ•´çš„å®ˆå«å­¦ä¹ ä¸é‡ç½®å­¦ä¹ æµç¨‹

**ä¸»æµç¨‹ä»£ç ** (main.py:47-49)ï¼š

```python
# 5. å­¦ä¹ å®ˆå«æ¡ä»¶å’Œé‡ç½®å‡½æ•°
adj = guard_learning(slice_data, get_feature, config)
evaluation.recording_time("guard_learning")

# 6. æ„å»ºæ··åˆè‡ªåŠ¨æœº
sys = build_system(slice_data, adj, get_feature)
```

**æ„å»ºç³»ç»Ÿ** (src/BuildSystem.py:18-36)ï¼š

```python
def build_system(data: list[Slice], res_adj: dict, get_feature):
    """ä»èšç±»ç»“æœå’Œå®ˆå«å­¦ä¹ ç»“æœæ„å»ºæ··åˆè‡ªåŠ¨æœº"""
    # 1. ä¸ºæ¯ä¸ªæ¨¡å¼æ”¶é›†æ‰€æœ‰æ•°æ®æ®µ
    data_of_mode = {}
    for cur in data:
        if not cur.valid:
            continue
        if data_of_mode.get(cur.mode) is None:
            data_of_mode[cur.mode] = [[], []]
        data_of_mode[cur.mode][0].append(cur.data)
        data_of_mode[cur.mode][1].append(cur.input_data)
    
    # 2. ä¸ºæ¯ä¸ªæ¨¡å¼æ‹Ÿåˆ NARX æ¨¡å‹ï¼ˆå·®åˆ†æ–¹ç¨‹ç³»ç»Ÿï¼‰
    mode_list = {}
    for (mode, cur_list) in data_of_mode.items():
        feature_list = get_feature(cur_list[0], cur_list[1], is_list=True)[0]
        mode_list[mode] = DESystem(feature_list, [], [], get_feature)
    
    # 3. æ„é€ é‚»æ¥è¡¨ï¼ˆå®ˆå«æ¡ä»¶ + é‡ç½®å‡½æ•°ï¼‰
    adj = {}
    for (u, v), (model, reset_fun) in res_adj.items():
        if adj.get(u) is None:
            adj[u] = []
        # åŒ…è£… SVM æ¨¡å‹ä¸ºå¯è°ƒç”¨å‡½æ•°
        adj[u].append((v, ModelFun(model), reset_fun))
    
    # 4. è¿”å›å®Œæ•´çš„æ··åˆè‡ªåŠ¨æœº
    return HybridAutomata(mode_list, adj)
```

**æ•°æ®ç»“æ„æ€»ç»“**ï¼š

```python
HybridAutomata = {
    mode_list: {
        mode_id â†’ DESystem(NARX_params, state_queue, input_queue)
    },
    adj: {
        mode_id â†’ [(target_mode, guard_svm, reset_fun), ...]
    }
}
```

#### 6.4 ä¸è®ºæ–‡ç†è®ºçš„å¯¹åº”å…³ç³»

| è®ºæ–‡æ¦‚å¿µ | ä»£ç å®ç° | æ–‡ä»¶ä½ç½® |
|---------|---------|---------|
| æ­£æ ·æœ¬é›† $(q, q')^+$ | `positive_sample[(u, v)]` | GuardLearning.py:26 |
| è´Ÿæ ·æœ¬é›† $(q, q')^-$ | `negative_sample[u]` | GuardLearning.py:19 |
| å®ˆå«æ¡ä»¶ $g$ | `SVC.predict()` | GuardLearning.py:39-42 |
| é‡ç½®å‡½æ•° $r$ | `ResetFun.__call__()` | Reset.py:29-34 |
| NARX æ¨¡å‹ $N_i$ | `eq_list[i]` | Reset.py:26 |
| æ··åˆè‡ªåŠ¨æœº $\hat{H}$ | `HybridAutomata` | BuildSystem.py:36 |

**å…³é”®åˆ›æ–°ç‚¹æ€»ç»“**ï¼š

1. **å®ˆå«å­¦ä¹ çš„å·§å¦™æ ·æœ¬æ„é€ **ï¼šé€šè¿‡"åŒä¸€æ¨¡å¼å†…çš„ä¸åŒåˆ‡æ¢ç›®æ ‡"å®šä¹‰è´Ÿæ ·æœ¬ï¼Œé¿å…è¿‡äºç®€å•çš„åˆ†ç±»é—®é¢˜
2. **é«˜é˜¶é‡ç½®çš„æ¸è¿›å¼ç”Ÿæˆ**ï¼šä¸æ˜¯ä¸€æ¬¡æ€§é‡ç½®ï¼Œè€Œæ˜¯é€šè¿‡ $k$ ä¸ª NARX æ¨¡å‹é€æ­¥ç”Ÿæˆæ–°çŠ¶æ€åºåˆ—
3. **ç»Ÿä¸€çš„ NARX æ¡†æ¶**ï¼šé‡ç½®å‡½æ•°æœ¬èº«ä¹Ÿæ˜¯ NARX æ¨¡å‹ï¼Œä¸æ¨¡å¼åŠ¨åŠ›å­¦ä¿æŒä¸€è‡´çš„æ•°å­¦å½¢å¼
4. **è‡ªé€‚åº”çš„æ ¸å‡½æ•°é€‰æ‹©**ï¼šé€šè¿‡é…ç½®æ–‡ä»¶çµæ´»é€‰æ‹© SVM æ ¸å‡½æ•°ï¼Œé€‚åº”ä¸åŒå¤æ‚åº¦çš„å®ˆå«æ¡ä»¶

### 7. Build Systemï¼ˆç³»ç»Ÿæ„å»ºï¼‰

**æ ¸å¿ƒåŠŸèƒ½**ï¼šå°†å‰åºæ­¥éª¤å­¦ä¹ åˆ°çš„æ‰€æœ‰ç»„ä»¶ï¼ˆæ¨¡å¼åŠ¨åŠ›å­¦ã€å®ˆå«æ¡ä»¶ã€é‡ç½®å‡½æ•°ï¼‰ç»„è£…æˆå®Œæ•´çš„æ··åˆè‡ªåŠ¨æœºã€‚

#### 7.1 ç³»ç»Ÿæ„å»ºä¸»å‡½æ•°

**å‡½æ•°ç­¾å** (BuildSystem.py:18-36)ï¼š
```python
def build_system(data: list[Slice], res_adj: dict, get_feature) -> HybridAutomata
```

**è¾“å…¥å‚æ•°**ï¼š
- `data: list[Slice]`ï¼šæ‰€æœ‰å·²èšç±»çš„æ•°æ®æ®µï¼ˆæ¯ä¸ªæ®µå·²æ ‡è®°æ¨¡å¼ IDï¼‰
- `res_adj: dict[(u,v)] = (svc_model, reset_fun)`ï¼šå®ˆå«å­¦ä¹ çš„è¾“å‡ºï¼ŒåŒ…å«ï¼š
  - é”®ï¼šæ¨¡å¼è½¬ç§»è¾¹ $(q_u, q_v)$
  - å€¼ï¼šå…ƒç»„ `(SVCæ¨¡å‹, ResetFunå¯¹è±¡)`
- `get_feature: FeatureExtractor`ï¼šNARX ç‰¹å¾æå–å™¨

**è¾“å‡º**ï¼š
- `HybridAutomata` å¯¹è±¡ï¼šå¯ç›´æ¥ç”¨äºä»¿çœŸçš„æ··åˆè‡ªåŠ¨æœº

#### 7.2 æ„å»ºæµç¨‹è¯¦è§£

**æ­¥éª¤ 1ï¼šæŒ‰æ¨¡å¼èšåˆæ•°æ®æ®µ** (BuildSystem.py:19-26)

```python
data_of_mode = {}  # {mode_id: [data_list, input_list]}
for cur in data:
    if not cur.valid:  # è·³è¿‡æ— æ•ˆæ®µ
        continue
    if data_of_mode.get(cur.mode) is None:
        data_of_mode[cur.mode] = [[], []]
    data_of_mode[cur.mode][0].append(cur.data)        # çŠ¶æ€æ•°æ®
    data_of_mode[cur.mode][1].append(cur.input_data)  # è¾“å…¥æ•°æ®
```

**æ•°æ®ç»“æ„ç¤ºä¾‹**ï¼š
```python
data_of_mode = {
    0: [[seg0_data, seg2_data, ...], [seg0_input, seg2_input, ...]],  # æ¨¡å¼ 0 çš„æ‰€æœ‰æ®µ
    1: [[seg1_data, seg3_data, ...], [seg1_input, seg3_input, ...]],  # æ¨¡å¼ 1 çš„æ‰€æœ‰æ®µ
}
```

**æ­¥éª¤ 2ï¼šä¸ºæ¯ä¸ªæ¨¡å¼å­¦ä¹  NARX æ¨¡å‹** (BuildSystem.py:28-30)

```python
mode_list = {}
for (mode, cur_list) in data_of_mode.items():
    # æå–æ‰€æœ‰æ®µçš„ç‰¹å¾çŸ©é˜µ Î›ï¼ˆè‡ªåŠ¨åˆå¹¶å¤šä¸ªæ®µï¼‰
    feature_list = get_feature(cur_list[0], cur_list[1], is_list=True)[0]
    # åˆ›å»º DESystemï¼ˆå·®åˆ†æ–¹ç¨‹ç³»ç»Ÿï¼‰
    mode_list[mode] = DESystem(feature_list, [], [], get_feature)
```

**å…³é”®ç‚¹**ï¼š
- `get_feature(..., is_list=True)` ä¼šè‡ªåŠ¨ï¼š
  1. å°†åŒä¸€æ¨¡å¼çš„å¤šä¸ªæ®µæ‹¼æ¥æˆå¤§çŸ©é˜µ
  2. æ‰§è¡Œ LLSQ æ±‚è§£ï¼š$\min \|O - \Lambda \cdot D\|_2$
  3. è¿”å›å­¦ä¹ åˆ°çš„ç³»æ•°çŸ©é˜µ `feature_list`ï¼ˆå³ $\Lambda$ï¼‰

- `DESystem` å¯¹è±¡å°è£…äº†ï¼š
  - NARX ç³»æ•° `eq`
  - çŠ¶æ€ç¼“å†²åŒº `state`ï¼ˆå­˜å‚¨å†å² $k$ æ­¥ï¼‰
  - è¾“å…¥ç¼“å†²åŒº `input_data`
  - å•æ­¥é¢„æµ‹å‡½æ•° `next()`

**æ­¥éª¤ 3ï¼šæ„å»ºè½¬ç§»è¾¹çš„é‚»æ¥è¡¨** (BuildSystem.py:31-35)

```python
adj = {}
for (u, v), (model, reset_fun) in res_adj.items():
    if adj.get(u) is None:
        adj[u] = []
    # å°† SVC æ¨¡å‹åŒ…è£…ä¸ºå¯è°ƒç”¨çš„å®ˆå«å‡½æ•°
    adj[u].append((v, ModelFun(model), reset_fun))
```

**æ•°æ®ç»“æ„è½¬æ¢**ï¼š
```python
# è¾“å…¥æ ¼å¼ï¼ˆæ¥è‡ª guard_learningï¼‰
res_adj = {
    (0, 1): (SVC_model_01, ResetFun_01),
    (1, 0): (SVC_model_10, ResetFun_10),
}

# è¾“å‡ºæ ¼å¼ï¼ˆé‚»æ¥è¡¨ï¼‰
adj = {
    0: [(1, guard_fun_01, reset_fun_01)],
    1: [(0, guard_fun_10, reset_fun_10)],
}
```

**æ­¥éª¤ 4ï¼šå®ä¾‹åŒ–æ··åˆè‡ªåŠ¨æœº** (BuildSystem.py:36)

```python
return HybridAutomata(mode_list, adj)
```

#### 7.3 å…³é”®è¾…åŠ©ç±»ï¼šModelFun

**å®ˆå«å‡½æ•°åŒ…è£…å™¨** (BuildSystem.py:10-15)ï¼š
```python
class ModelFun:
    def __init__(self, model):
        self.model = copy.copy(model)  # æ·±æ‹·è´ SVC æ¨¡å‹
    
    def __call__(self, *args):
        # å°† SVC çš„æ¦‚ç‡è¾“å‡ºè½¬æ¢ä¸ºå¸ƒå°”å®ˆå«
        return self.model.predict([[*args]])[0] > 0.5
```

**è®¾è®¡æ„å›¾**ï¼š
- ç»Ÿä¸€æ¥å£ï¼šå°† SVM åˆ†ç±»å™¨è½¬æ¢ä¸ºæ ‡å‡†çš„å®ˆå«å‡½æ•° $g: \mathbb{R}^n \to \{0,1\}$
- é˜ˆå€¼åŒ–ï¼š`> 0.5` å°†è½¯åˆ†ç±»è½¬ä¸ºç¡¬å†³ç­–
- è°ƒç”¨æ–¹å¼ï¼š`guard_fun(x0, x1, ..., xn)` è¿”å› `True/False`

#### 7.4 åˆå§‹çŠ¶æ€æ„é€ å‡½æ•°

**å‡½æ•°ç­¾å** (BuildSystem.py:39-49)ï¼š
```python
def get_init_state(data_list, mode_map, mode_list, bias) -> list[dict]
```

**ç”¨é€”**ï¼šä¸ºä»¿çœŸå‡†å¤‡åˆå§‹çŠ¶æ€ï¼ˆåŒ…å«æ¨¡å¼ ID å’Œå†å²çŠ¶æ€ï¼‰

**å‚æ•°è¯´æ˜**ï¼š
- `data_list`ï¼šåŸå§‹è½¨è¿¹æ•°æ®åˆ—è¡¨
- `mode_map: dict[str, int]`ï¼šæ¨¡å¼åç§°åˆ° ID çš„æ˜ å°„ï¼ˆå¦‚ `{"mode_A": 0}`ï¼‰
- `mode_list`ï¼šæ¯æ¡è½¨è¿¹å¯¹åº”çš„æ¨¡å¼åºåˆ—
- `bias`ï¼šNARX æ¨¡å‹çš„é˜¶æ•°ï¼ˆéœ€è¦ `bias` æ­¥å†å²ï¼‰

**å®ç°é€»è¾‘**ï¼š
```python
res = []
for data, mode in zip(data_list, mode_list):
    # æŸ¥æ‰¾åˆå§‹æ¨¡å¼ ID
    if mode_map.get(mode[bias - 1]) is None:
        raise Exception("unknown mode: " + str(mode[bias - 1]))
    
    init_state = {'mode': mode_map[mode[bias - 1]]}
    
    # ä¸ºæ¯ä¸ªçŠ¶æ€å˜é‡æå–å†å²åºåˆ—ï¼ˆé€†åºï¼‰
    for i in range(data.shape[0]):
        # data[i, (bias-1)::-1] æå– [t_{bias-1}, t_{bias-2}, ..., t_0]
        init_state['x' + str(i)] = data[i, (bias - 1)::-1]
    
    res.append(init_state)
return res
```

**è¾“å‡ºç¤ºä¾‹**ï¼ˆorder=3 çš„ 2 ç»´ç³»ç»Ÿï¼‰ï¼š
```python
init_state = {
    'mode': 0,
    'x0': [x0[2], x0[1], x0[0]],  # å˜é‡ x0 çš„å†å² 3 æ­¥ï¼ˆé€†åºï¼‰
    'x1': [x1[2], x1[1], x1[0]],  # å˜é‡ x1 çš„å†å² 3 æ­¥
}
```

#### 7.5 æ„å»ºçš„æ··åˆè‡ªåŠ¨æœºç»“æ„

**HybridAutomata ç±»** (HybridAutomata.py:46-56)ï¼š
```python
class HybridAutomata:
    def __init__(self, mode_list, adj, init_mode=None):
        self.mode_state = init_mode       # å½“å‰æ¨¡å¼
        self.mode_list = mode_list        # {mode_id: DESystem}
        self.adj = adj                    # {mode_id: [(target, guard, reset)]}
```

**æ ¸å¿ƒæ–¹æ³•**ï¼š

1. **å•æ­¥ä»¿çœŸ** (HybridAutomata.py:82-110)ï¼š
```python
def next(self, *args):
    # 1. åœ¨å½“å‰æ¨¡å¼æ‰§è¡ŒåŠ¨åŠ›å­¦
    res = list(self.mode_list[self.mode_state].next(*args))
    
    # 2. æ£€æŸ¥æ‰€æœ‰å‡ºè¾¹çš„å®ˆå«æ¡ä»¶
    for to, fun, reset_val in self.adj.get(self.mode_state, {}):
        if fun(*res):  # å®ˆå«è§¦å‘
            self.mode_state = to
            # 3. åº”ç”¨é‡ç½®å‡½æ•°ï¼ˆå¦‚æœæœ‰ï¼‰
            self.mode_list[to].load(self.mode_list[mode_state], reset_val)
            break
    
    return res, mode_state, switched
```

2. **çŠ¶æ€é‡ç½®** (HybridAutomata.py:112-114)ï¼š
```python
def reset(self, init_state, dt=None, *args):
    self.mode_state = init_state.get('mode', self.mode_state)
    self.mode_list[self.mode_state].reset(init_state, dt, *args)
```

#### 7.6 DESystem çš„å†…éƒ¨æœºåˆ¶

**å·®åˆ†æ–¹ç¨‹ç³»ç»Ÿ** (DE_System.py:10-50)ï¼š

**çŠ¶æ€ç®¡ç†**ï¼š
```python
class DESystem:
    def __init__(self, eq, init_state, input_data, config: FeatureExtractor, reset_fun=None):
        self.eq = eq.copy()                    # NARX ç³»æ•°çŸ©é˜µ Î›
        self.state = init_state.copy()         # å†å²çŠ¶æ€é˜Ÿåˆ—
        self.input_data = input_data.copy()    # å†å²è¾“å…¥é˜Ÿåˆ—
        self.reset_fun = reset_fun             # é‡ç½®å‡½æ•°ï¼ˆå¯é€‰ï¼‰
```

**å•æ­¥é¢„æµ‹**ï¼š
```python
def next(self, input_val=None):
    # 1. æ›´æ–°è¾“å…¥ç¼“å†²åŒº
    for i in range(self.config.input_num):
        self.input_data[i].appendleft(input_val[i])
    
    # 2. è®¡ç®—ä¸‹ä¸€çŠ¶æ€
    if self.reset_fun is None or not self.reset_fun.valid():
        # æ­£å¸¸æ¨¡å¼ï¼šNARX é¢„æµ‹
        for i in range(self.var_num):
            res.append(np.dot(self.config.get_items(self.state, self.input_data, i), 
                             self.eq[i]))
    else:
        # é‡ç½®æ¨¡å¼ï¼šä½¿ç”¨æ¸è¿›å¼é‡ç½®å‡½æ•°
        res = self.reset_fun(self.state, self.input_data, self.var_num)
    
    # 3. æ›´æ–°çŠ¶æ€ç¼“å†²åŒºï¼ˆFIFOï¼‰
    for i in range(self.var_num):
        self.state[i].pop()                # ç§»é™¤æœ€æ—§çš„çŠ¶æ€
        self.state[i].appendleft(res[i])   # æ·»åŠ æ–°çŠ¶æ€åˆ°é˜Ÿé¦–
    
    return res
```

**å…³é”®è®¾è®¡**ï¼š
- ä½¿ç”¨ `deque` å®ç°å›ºå®šé•¿åº¦çš„æ»‘åŠ¨çª—å£
- `appendleft()` + `pop()` ä¿è¯ FIFO é¡ºåº
- `get_items()` è‡ªåŠ¨æå–å½“å‰çª—å£çš„ NARX ç‰¹å¾

#### 7.7 é‡ç½®å‡½æ•°çš„é›†æˆ

**ResetFun ç±»** (Reset.py:7-41)ï¼š

**æ¸è¿›å¼é‡ç½®æœºåˆ¶**ï¼š
```python
class ResetFun:
    def __init__(self, get_feature, fit_order, eq_list):
        self.fit_order = fit_order  # éœ€è¦ k æ­¥æ‰èƒ½å®Œå…¨é‡ç½®
        self.eq_list = eq_list      # [Î›_1, Î›_2, ..., Î›_k]
        self.cnt = 0                # å½“å‰é‡ç½®æ­¥æ•°
    
    def __call__(self, state, input_data, var_num):
        res = []
        for i in range(var_num):
            # ä½¿ç”¨ç¬¬ cnt æ­¥çš„ NARX æ¨¡å‹
            res.append(np.dot(self.get_feature.get_items(state, input_data, i), 
                             self.eq_list[self.cnt][i]))
        self.cnt += 1
        return res
    
    def valid(self):
        return self.cnt < self.fit_order  # æœªå®Œæˆæ‰€æœ‰é‡ç½®æ­¥éª¤
```

**å·¥ä½œæµç¨‹**ï¼š
1. æ¨¡å¼åˆ‡æ¢å‘ç”Ÿæ—¶ï¼Œ`DESystem.load()` è®¾ç½® `reset_fun`
2. æ¥ä¸‹æ¥ $k$ æ­¥è°ƒç”¨ `next()` æ—¶ï¼š
   - `reset_fun.valid()` è¿”å› `True`
   - ä½¿ç”¨ `eq_list[cnt]` è€Œéæ­£å¸¸çš„ `eq`
   - æ¯æ­¥ `cnt` è‡ªå¢
3. $k$ æ­¥åï¼Œ`valid()` è¿”å› `False`ï¼Œæ¢å¤æ­£å¸¸ NARX é¢„æµ‹

#### 7.8 æ•°æ®æµæ€»ç»“

```
guard_learning() è¾“å‡º
    â†“
res_adj = {(u,v): (SVC_model, ResetFun)}
    â†“
build_system()
    â†“
    â”œâ”€ èšåˆåŒæ¨¡å¼æ•°æ®æ®µ â†’ data_of_mode
    â”œâ”€ å­¦ä¹  NARX ç³»æ•° â†’ mode_list[mode] = DESystem(Î›)
    â”œâ”€ åŒ…è£…å®ˆå«å‡½æ•° â†’ adj[u] = [(v, ModelFun(SVC), reset)]
    â””â”€ å®ä¾‹åŒ– HybridAutomata(mode_list, adj)
    â†“
å¯ä»¿çœŸçš„æ··åˆè‡ªåŠ¨æœº
    â†“
HybridAutomata.next() å¾ªç¯è°ƒç”¨
    â†“
    â”œâ”€ DESystem.next() â†’ æ¨¡å¼å†…åŠ¨åŠ›å­¦
    â”œâ”€ ModelFun(*state) â†’ å®ˆå«æ£€æµ‹
    â””â”€ ResetFun(*state) â†’ æ¨¡å¼åˆ‡æ¢é‡ç½®
```

#### 7.9 ä¸è®ºæ–‡ç¬¦å·çš„å¯¹åº”

| è®ºæ–‡ç¬¦å· | ä»£ç å®ç° | æ–‡ä»¶ä½ç½® |
|---------|---------|---------|
| æ··åˆè‡ªåŠ¨æœº $\hat{H} = (Q, X, f, E, G, R)$ | `HybridAutomata` | BuildSystem.py:36 |
| æ¨¡å¼é›†åˆ $Q$ | `mode_list: dict[int, DESystem]` | BuildSystem.py:30 |
| çŠ¶æ€ç©ºé—´ $X$ | `DESystem.state` | DE_System.py:15 |
| æ¨¡å¼åŠ¨åŠ›å­¦ $f_q$ | `DESystem.eq` (NARX ç³»æ•°) | DE_System.py:17 |
| è½¬ç§»è¾¹é›†åˆ $E$ | `adj: dict[int, list[tuple]]` | BuildSystem.py:35 |
| å®ˆå«æ¡ä»¶ $G$ | `ModelFun(SVC)` | BuildSystem.py:10-15 |
| é‡ç½®æ˜ å°„ $R$ | `ResetFun` | Reset.py:7-41 |
| å•æ­¥æ¼”åŒ– $x[t+1] = f_q(x[t], u[t])$ | `DESystem.next()` | DE_System.py:34-50 |
| æ¨¡å¼åˆ‡æ¢ $q' \in \text{Post}(q, x)$ | `HybridAutomata.next()` | HybridAutomata.py:82-110 |

**å…³é”®åˆ›æ–°ç‚¹**ï¼š
1. **ç»Ÿä¸€çš„ NARX æ¡†æ¶**ï¼šæ¨¡å¼åŠ¨åŠ›å­¦å’Œé‡ç½®å‡½æ•°éƒ½ç”¨ NARX è¡¨ç¤ºï¼Œä¿æŒæ•°å­¦ä¸€è‡´æ€§
2. **æ¸è¿›å¼é‡ç½®**ï¼šä¸æ˜¯ç¬æ—¶è·³å˜ï¼Œè€Œæ˜¯ç”¨ $k$ æ­¥ NARX æ¨¡å‹å¹³æ»‘è¿‡æ¸¡
3. **å¯ç»„åˆçš„æ¶æ„**ï¼š`DESystem`ã€`ModelFun`ã€`ResetFun` ç‹¬ç«‹å°è£…ï¼Œæ˜“äºæ‰©å±•
4. **é«˜æ•ˆçš„çŠ¶æ€ç®¡ç†**ï¼šç”¨ `deque` å®ç° $O(1)$ çš„å†å²çª—å£æ›´æ–°

### 8. å®Œæ•´çš„è¯†åˆ«æµç¨‹

**ä¸»æµç¨‹ä»£ç ** (main.py:23-47)ï¼š
```python
def run(data_list, input_data, config, evaluation: Evaluation):
    """æ··åˆç³»ç»Ÿè¯†åˆ«ä¸»æµç¨‹"""
    input_data = np.array(input_data)

    # 1. åˆå§‹åŒ– NARX ç‰¹å¾æå–å™¨
    get_feature = FeatureExtractor(len(data_list[0]), len(input_data[0]),
                                   order=config['order'], dt=config['dt'],
                                   minus=config['minus'],
                                   need_bias=config['need_bias'],
                                   other_items=config['other_items'])

    Slice.clear()
    slice_data = []
    chp_list = []

    # 2. åˆ†å‰²ï¼šå¯¹æ¯æ¡è®­ç»ƒè½¨è¿¹æ£€æµ‹åˆ‡æ¢ç‚¹
    for data, input_val in zip(data_list, input_data):
        change_points = find_change_point(data, input_val, get_feature,
                                        w=config['window_size'])
        chp_list.append(change_points)
        print("ChP:\t", change_points)
        slice_curve(slice_data, data, input_val, change_points, get_feature)

    evaluation.submit(chp=chp_list)
    evaluation.recording_time("change_points")

    # 3. é˜ˆå€¼æ ¡å‡†
    Slice.Method = config['clustering_method']
    Slice.fit_threshold(slice_data)

    # 4. èšç±»ï¼šè¯†åˆ«æ¨¡å¼
    clustering(slice_data, config['self_loop'])
    evaluation.recording_time("clustering")

    # 5. å­¦ä¹ å®ˆå«æ¡ä»¶ï¼ˆæ¨¡å¼åˆ‡æ¢è§„åˆ™ï¼‰
    adj = guard_learning(slice_data, get_feature, config)
    evaluation.recording_time("guard_learning")

    # 6. æ„å»ºæ··åˆè‡ªåŠ¨æœº
    sys = build_system(slice_data, adj, get_feature)
    evaluation.stop("total")
    evaluation.submit(slice_data=slice_data)

    return sys, slice_data
```

**æµç¨‹æ€»ç»“**ï¼š
```
è¾“å…¥æ•°æ®
   â†“
[1] æ»‘åŠ¨çª—å£ + NARXæ‹Ÿåˆ â†’ æ£€æµ‹åˆ‡æ¢ç‚¹ â†’ æ•°æ®æ®µåˆ—è¡¨
   â†“
[2] åŠ¨æ€æ ¡å‡†é˜ˆå€¼ â† ç›¸é‚»æ®µæ‹Ÿåˆè¯¯å·®ç»Ÿè®¡
   â†“
[3] åŸºäºæ‹Ÿåˆèƒ½åŠ›çš„èšç±» â†’ æ¨¡å¼è¯†åˆ«
   â†“
[4] SVMå­¦ä¹ å®ˆå«æ¡ä»¶ â†’ åˆ‡æ¢è§„åˆ™
   â†“
[5] æ„å»ºæ··åˆè‡ªåŠ¨æœº â† æ¨¡å¼+åˆ‡æ¢è§„åˆ™+é‡ç½®å‡½æ•°
   â†“
è¾“å‡ºï¼šå¯ä»¿çœŸçš„æ··åˆç³»ç»Ÿæ¨¡å‹
```

### 9. å®éªŒé…ç½®ç¤ºä¾‹

**Duffing æŒ¯å­é…ç½®** (automata/non_linear/duffing.json)ï¼š
```json
{
  "config": {
    "order": 3,                    // NARX æ¨¡å‹é˜¶æ•°
    "window_size": 10,             // æ»‘åŠ¨çª—å£å¤§å°
    "clustering_method": "fit",    // èšç±»æ–¹æ³•ï¼š"fit"ï¼ˆæ‹Ÿåˆèƒ½åŠ›ï¼‰æˆ– "dis"ï¼ˆè·ç¦»ï¼‰
    "need_bias": true,             // æ˜¯å¦åŒ…å«åç½®é¡¹
    "need_reset": false,           // æ˜¯å¦å­¦ä¹ çŠ¶æ€é‡ç½®å‡½æ•°
    "kernel": "linear",            // SVM æ ¸å‡½æ•°
    "svm_c": 1e6,                  // SVM æ­£åˆ™åŒ–å‚æ•°
    "other_items": "",             // è‡ªå®šä¹‰éçº¿æ€§é¡¹ï¼ˆå¦‚ "x[1]*x[2]"ï¼‰
    "minus": false,                // æ˜¯å¦è‡ªåŠ¨å‡å°‘æ¨¡å‹é˜¶æ•°
    "self_loop": false,            // æ˜¯å¦å…è®¸è‡ªç¯ï¼ˆåŒä¸€æ¨¡å¼å†…è·³è½¬ï¼‰
    "class_weight": 1.0,           // SVM ç±»åˆ«æƒé‡
    "dt": 0.01,                    // é‡‡æ ·æ—¶é—´é—´éš”
    "total_time": 10               // ä»¿çœŸæ€»æ—¶é•¿
  }
}
```

**å…³é”®å‚æ•°è¯´æ˜**ï¼š
- `order`ï¼šå†³å®šäº† NARX æ¨¡å‹èƒ½æ•æ‰å¤šé•¿çš„æ—¶é—´ä¾èµ–ï¼ˆé€šå¸¸ 2-5ï¼‰
- `window_size`ï¼šçª—å£è¶Šå¤§ï¼Œå¯¹å™ªå£°è¶Šé²æ£’ï¼Œä½†å¯èƒ½é”™è¿‡çŸ­æš‚çš„æ¨¡å¼
- `clustering_method = "fit"`ï¼šæ¨èè®¾ç½®ï¼ŒåŸºäºç‰©ç†æ„ä¹‰çš„æ‹Ÿåˆèƒ½åŠ›èšç±»
- `other_items`ï¼šå¯æ‰©å±•æ€§æ¥å£ï¼Œç”¨äºæ·»åŠ é¢†åŸŸçŸ¥è¯†çš„éçº¿æ€§é¡¹

### æ–¹æ³•å…¬å¼åŒ–

**ç³»ç»Ÿæ¨¡å¼è¯†åˆ« = Â¬ (å•ä¸€ NARX æ¨¡å‹ æ‹Ÿåˆ æ•°æ®æ®µ)** + **(æ¨¡å‹å‚æ•°é›† â‰ˆ æ¨¡å¼æ ‡è¯†)**

è¿™ä¸ªå…¬å¼è¡¨è¾¾äº†ï¼š
1.  æ¨¡å¼çš„**åˆ‡æ¢ç‚¹**é€šè¿‡åˆ¤æ–­â€œå•ä¸€NARXæ¨¡å‹æ— æ³•æ‹Ÿåˆå½“å‰æ•°æ®æ®µâ€æ¥ç¡®å®šï¼ˆç”¨é€»è¾‘éâ€œÂ¬â€è¡¨ç¤ºï¼‰ã€‚
2.  æ¨¡å¼çš„**ç±»åˆ«**é€šè¿‡â€œèƒ½å¤ŸæˆåŠŸæ‹ŸåˆæŸæ•°æ®æ®µçš„æ¨¡å‹å‚æ•°é›†â€æ¥å®šä¹‰å’Œèšç±»ã€‚

### æœ€ç»ˆåŒé‡æ€»ç»“

*   **ä¸€å¥è¯æ€»ç»“ (æ ¸å¿ƒä»·å€¼)**
    ä¸ºäº†è§£å†³ä¼ ç»Ÿæ–¹æ³•ä¾èµ–è„†å¼±çš„å¯¼æ•°é˜ˆå€¼æ¥è¯†åˆ«æ··åˆç³»ç»Ÿæ¨¡å¼åˆ‡æ¢çš„æ ¹æœ¬é—®é¢˜ï¼Œè¯¥ç ”ç©¶æå‡ºäº†ä¸€ç§åˆ›æ–°çš„åˆ‡å…¥è§†è§’â€”â€”å³æ¨¡å¼åˆ‡æ¢çš„æœ¬è´¨æ˜¯å•ä¸€åŠ¨æ€æ¨¡å‹çš„æ‹Ÿåˆå¤±æ•ˆâ€”â€”å¹¶ä»¥æ­¤ä¸ºåŸºç¡€ï¼Œé€šè¿‡å°†éçº¿æ€§è‡ªå›å½’ï¼ˆNARXï¼‰æ¨¡å‹çš„æ‹Ÿåˆæ®‹å·®ä½œä¸ºä¸€ç§ç»Ÿä¸€ã€æ— é˜ˆå€¼çš„å†…åœ¨æ ‡å‡†ï¼ŒæˆåŠŸåœ°å®ç°äº†å¯¹é«˜é˜¶éçº¿æ€§æ··åˆç³»ç»Ÿç»“æ„ä¸åŠ¨æ€çš„ç²¾ç¡®æ¨æ–­ã€‚

*   **ä¸€å¥è¯æ€»ç»“ (å¤§ç™½è¯ç‰ˆ)**
    è¦åˆ¤æ–­ä¸€ä¸ªæœºå™¨äººå•¥æ—¶å€™åˆ‡æ¢äº†æ–°ä»»åŠ¡ï¼Œåˆ«è´¹åŠ²å»çœ‹å®ƒçš„é€Ÿåº¦æ˜¯ä¸æ˜¯çªç„¶å˜å¿«äº†ï¼Œä½ åªè¦ä¸€ç›´ç”¨åŒä¸€ä¸ªâ€œè¡Œä¸ºè¯´æ˜ä¹¦â€å»å¥—å®ƒçš„åŠ¨ä½œï¼Œå½“è¯´æ˜ä¹¦çªç„¶å¯¹ä¸ä¸Šå·çš„é‚£ä¸€åˆ»ï¼Œå°±è¯´æ˜å®ƒæ¢ä»»åŠ¡äº†ã€‚